"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bcs = void 0;
const bcs_1 = require("@mysten/bcs");
const core_1 = require("../core");
const initiaAddress = (options) => bcs_1.bcs.bytes(32, options).transform({
    input: (val) => {
        if (val.startsWith('init1')) {
            val = core_1.AccAddress.toHex(val);
        }
        if (val.startsWith('0x')) {
            val = val.slice(2).padStart(64, '0');
        }
        if (!val.match(/[0-9a-f]+$/i)) {
            throw new Error('invalid address');
        }
        return Buffer.from(val, 'hex');
    },
    output: val => `0x${Buffer.from(val).toString('hex')}`,
});
// initia specific types
const initiaBcs = {
    /**
     * Creates a BcsType that can be used to read and write an address.
     * @example
     * bcs.address().serialize('0x1') // in hex
     * bcs.address().serialize('init1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpqr5e3d') // in bech32
     */
    address: initiaAddress,
    /**
     * Creates a BcsType that can be used to read and write an object.
     * @example
     * bcs.object().serialize('0x1') // in hex
     * bcs.object().serialize('init1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpqr5e3d') // in bech32
     */
    object: initiaAddress,
    /**
     * Creates a BcsType that can be used to read and write a fixed_point32.
     * @example
     * bcs.fixed_point32().serialize('1.23')
     */
    fixed_point32: (options) => bcs_1.bcs.u64(options).transform({
        input: (val) => {
            const n = (0, core_1.num)(val).times(new core_1.BigNumber('4294967296'));
            return n.toFixed(0, core_1.BigNumber.ROUND_DOWN);
        },
        output: val => (0, core_1.num)(val).div(new core_1.BigNumber('4294967296')).toNumber(),
    }),
    /**
     * Creates a BcsType that can be used to read and write a fixed_point64.
     * @example
     * bcs.fixed_point64().serialize('1.23')
     */
    fixed_point64: (options) => bcs_1.bcs.u128(options).transform({
        input: (val) => {
            const n = (0, core_1.num)(val).times(new core_1.BigNumber('18446744073709551616'));
            return n.toFixed(0, core_1.BigNumber.ROUND_DOWN);
        },
        output: val => (0, core_1.num)(val).div(new core_1.BigNumber('18446744073709551616')).toNumber(),
    }),
    /**
     * Creates a BcsType that can be used to read and write a decimal128.
     * @example
     * bcs.decimal128().serialize('1.23')
     */
    decimal128: (options) => bcs_1.bcs.u128(options).transform({
        input: (val) => {
            const n = (0, core_1.num)(val).times(new core_1.BigNumber('1000000000000000000'));
            return n.toFixed(0, core_1.BigNumber.ROUND_DOWN);
        },
        output: val => (0, core_1.num)(val).div(new core_1.BigNumber('1000000000000000000')).toNumber(),
    }),
    /**
     * Creates a BcsType that can be used to read and write a decimal256.
     * @example
     * bcs.decimal256().serialize('1.23')
     */
    decimal256: (options) => bcs_1.bcs.u256(options).transform({
        input: (val) => {
            const n = (0, core_1.num)(val).times(new core_1.BigNumber('1000000000000000000'));
            return n.toFixed(0, core_1.BigNumber.ROUND_DOWN);
        },
        output: val => (0, core_1.num)(val).div(new core_1.BigNumber('1000000000000000000')).toNumber(),
    }),
};
exports.bcs = Object.assign(Object.assign({}, bcs_1.bcs), initiaBcs);
//# sourceMappingURL=bcs.js.map