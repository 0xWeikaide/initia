import { BcsTypeOptions } from '@mysten/bcs';
export declare const bcs: {
    /**
     * Creates a BcsType that can be used to read and write an address.
     * @example
     * bcs.address().serialize('0x1') // in hex
     * bcs.address().serialize('init1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpqr5e3d') // in bech32
     */
    address: (options?: BcsTypeOptions<Uint8Array, Iterable<number>>) => import("@mysten/bcs").BcsType<string, string>;
    /**
     * Creates a BcsType that can be used to read and write an object.
     * @example
     * bcs.object().serialize('0x1') // in hex
     * bcs.object().serialize('init1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqpqr5e3d') // in bech32
     */
    object: (options?: BcsTypeOptions<Uint8Array, Iterable<number>>) => import("@mysten/bcs").BcsType<string, string>;
    /**
     * Creates a BcsType that can be used to read and write a fixed_point32.
     * @example
     * bcs.fixed_point32().serialize('1.23')
     */
    fixed_point32: (options?: BcsTypeOptions<string, string | number | bigint>) => import("@mysten/bcs").BcsType<number, string | number>;
    /**
     * Creates a BcsType that can be used to read and write a fixed_point64.
     * @example
     * bcs.fixed_point64().serialize('1.23')
     */
    fixed_point64: (options?: BcsTypeOptions<string, string | number | bigint>) => import("@mysten/bcs").BcsType<number, string | number>;
    /**
     * Creates a BcsType that can be used to read and write a decimal128.
     * @example
     * bcs.decimal128().serialize('1.23')
     */
    decimal128: (options?: BcsTypeOptions<string, string | number | bigint>) => import("@mysten/bcs").BcsType<number, string | number>;
    /**
     * Creates a BcsType that can be used to read and write a decimal256.
     * @example
     * bcs.decimal256().serialize('1.23')
     */
    decimal256: (options?: BcsTypeOptions<string, string | number | bigint>) => import("@mysten/bcs").BcsType<number, string | number>;
    u8(options?: BcsTypeOptions<number, number> | undefined): import("@mysten/bcs").BcsType<number, number>;
    u16(options?: BcsTypeOptions<number, number> | undefined): import("@mysten/bcs").BcsType<number, number>;
    u32(options?: BcsTypeOptions<number, number> | undefined): import("@mysten/bcs").BcsType<number, number>;
    u64(options?: BcsTypeOptions<string, string | number | bigint> | undefined): import("@mysten/bcs").BcsType<string, string | number | bigint>;
    u128(options?: BcsTypeOptions<string, string | number | bigint> | undefined): import("@mysten/bcs").BcsType<string, string | number | bigint>;
    u256(options?: BcsTypeOptions<string, string | number | bigint> | undefined): import("@mysten/bcs").BcsType<string, string | number | bigint>;
    bool(options?: BcsTypeOptions<boolean, boolean> | undefined): import("@mysten/bcs").BcsType<boolean, boolean>;
    uleb128(options?: BcsTypeOptions<number, number> | undefined): import("@mysten/bcs").BcsType<number, number>;
    bytes<T extends number>(size: T, options?: BcsTypeOptions<Uint8Array, Iterable<number>> | undefined): import("@mysten/bcs").BcsType<Uint8Array, Uint8Array>;
    string(options?: BcsTypeOptions<string, string> | undefined): import("@mysten/bcs").BcsType<string, string>;
    fixedArray<T_1, Input>(size: number, type: import("@mysten/bcs").BcsType<T_1, Input>, options?: BcsTypeOptions<T_1[], Iterable<Input> & {
        length: number;
    }> | undefined): import("@mysten/bcs").BcsType<T_1[], Iterable<Input> & {
        length: number;
    }>;
    option<T_2, Input_1>(type: import("@mysten/bcs").BcsType<T_2, Input_1>): import("@mysten/bcs").BcsType<T_2 | null, Input_1 | null | undefined>;
    vector<T_3, Input_2>(type: import("@mysten/bcs").BcsType<T_3, Input_2>, options?: BcsTypeOptions<T_3[], Iterable<Input_2> & {
        length: number;
    }> | undefined): import("@mysten/bcs").BcsType<T_3[], Iterable<Input_2> & {
        length: number;
    }>;
    tuple<const Types extends readonly import("@mysten/bcs").BcsType<any, any>[]>(types: Types, options?: BcsTypeOptions<{ -readonly [K in keyof Types]: Types[K] extends import("@mysten/bcs").BcsType<infer T_4, any> ? T_4 : never; }, { [K_1 in keyof Types]: Types[K_1] extends import("@mysten/bcs").BcsType<any, infer T_5> ? T_5 : never; }> | undefined): import("@mysten/bcs").BcsType<{ -readonly [K_2 in keyof Types]: Types[K_2] extends import("@mysten/bcs").BcsType<infer T_6, any> ? T_6 : never; }, { [K_3 in keyof Types]: Types[K_3] extends import("@mysten/bcs").BcsType<any, infer T_7> ? T_7 : never; }>;
    struct<T_8 extends Record<string, import("@mysten/bcs").BcsType<any, any>>>(name: string, fields: T_8, options?: Omit<BcsTypeOptions<{ [K_4 in keyof T_8]: T_8[K_4] extends import("@mysten/bcs").BcsType<infer U, any> ? U : never; }, { [K_5 in keyof T_8]: T_8[K_5] extends import("@mysten/bcs").BcsType<any, infer U_1> ? U_1 : never; }>, "name"> | undefined): import("@mysten/bcs").BcsType<{ [K_6 in keyof T_8]: T_8[K_6] extends import("@mysten/bcs").BcsType<infer U_2, any> ? U_2 : never; }, { [K_7 in keyof T_8]: T_8[K_7] extends import("@mysten/bcs").BcsType<any, infer U_3> ? U_3 : never; }>;
    enum<T_9 extends Record<string, import("@mysten/bcs").BcsType<any, any> | null>>(name: string, values: T_9, options?: Omit<BcsTypeOptions<{ [K_8 in keyof T_9]: T_9[K_8] extends import("@mysten/bcs").BcsType<infer U_4, any> ? { [K2 in K_8]: U_4; } : { [K2_1 in K_8]: true; }; }[keyof T_9], { [K_9 in keyof T_9]: T_9[K_9] extends import("@mysten/bcs").BcsType<any, infer U_5> ? { [K2_2 in K_9]: U_5; } : { [K2_3 in K_9]: unknown; }; }[keyof T_9]>, "name"> | undefined): import("@mysten/bcs").BcsType<{ [K_10 in keyof T_9]: T_9[K_10] extends import("@mysten/bcs").BcsType<infer U_6, any> ? { [K2_4 in K_10]: U_6; } : { [K2_5 in K_10]: true; }; }[keyof T_9], { [K_11 in keyof T_9]: T_9[K_11] extends import("@mysten/bcs").BcsType<any, infer U_7> ? { [K2_6 in K_11]: U_7; } : { [K2_7 in K_11]: unknown; }; }[keyof T_9]>;
    map<K_12, V, InputK = K_12, InputV = V>(keyType: import("@mysten/bcs").BcsType<K_12, InputK>, valueType: import("@mysten/bcs").BcsType<V, InputV>): import("@mysten/bcs").BcsType<Map<K_12, V>, Map<InputK, InputV>>;
    generic<const Names extends readonly string[], const Type extends import("@mysten/bcs").BcsType<any, any>>(_names: Names, cb: (...types: { [K_13 in keyof Names]: import("@mysten/bcs").BcsType<import("@mysten/bcs/dist/cjs/types").GenericPlaceholder<Names[K_13]>, import("@mysten/bcs/dist/cjs/types").GenericPlaceholder<Names[K_13]>>; }) => Type): <T_10 extends { [K_14 in keyof Names]: import("@mysten/bcs").BcsType<any, any>; }>(...types: T_10) => import("@mysten/bcs/dist/cjs/types").ReplaceBcsGenerics<Type, Names, T_10>;
    lazy<T_11 extends import("@mysten/bcs").BcsType<any, any>>(cb: () => T_11): T_11;
};
