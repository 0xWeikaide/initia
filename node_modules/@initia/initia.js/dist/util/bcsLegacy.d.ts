import { StructTypeDefinition } from '@mysten/bcs';
import { MoveFunctionABI } from '../core/move/types';
import { Encoding } from '@mysten/bcs/dist/esm/types';
export declare class BCS {
    private static bcs;
    private mystenBcs;
    private addressLength;
    static readonly U8: string;
    static readonly U16: string;
    static readonly U32: string;
    static readonly U64: string;
    static readonly U128: string;
    static readonly U256: string;
    static readonly BOOL: string;
    static readonly VECTOR: string;
    static readonly ADDRESS: string;
    static readonly STRING: string;
    static readonly OPTION: string;
    static readonly OBJECT: string;
    static readonly FIXED_POINT32: string;
    static readonly FIXED_POINT64: string;
    static readonly DECIMAL128: string;
    static readonly DECIMAL256: string;
    private constructor();
    static getInstance(): BCS;
    /**
     * Serialize data to bcs.
     * Return base64 encoded string
     *
     * Preregistered types : `u8`, `u16`, `u32`, `u64`, `u128`, `u256`,
     *   `bool`, `vector`, `address`, `string`, `option`
     *
     * @example
     * const bcs = BCS.getInstance();
     *
     * const num = bcs.serialize(BCS.U64, 2187462); // numeric
     * const bool = bcs.serialize(BCS.BOOL, true); // bool
     * const vector = bcs.serialize('vector<u64>', [1, 2, 3, 4]); // vector
     * const string = bcs.serialize(BCS.STRING, 'initia'); // string
     * const optionSome = bcs.serialize('option<u64>', 18237); // option some
     * const optionNone = bcs.serialize('option<u64>', null); // option none
     *
     * @param type Name of the type of serialize
     * @param data Data to serialize
     * @param size Serialization buffer size. Default 1024 bytes
     * @return Base64 encoded of serialized data
     */
    serialize(type: string, data: any, size?: number): string;
    /**
     * Deserialize bcs.
     *
     * @example
     *
     * const bcs = BCS.getInstance();
     *
     * const num = bcs.serialize(BCS.U64, 2187462);
     * const deNum = bcs.deserialize(BCS.U64, 2187462);
     *
     * @param type Name of the type of deserialize
     * @param data  Data to deserialize
     * @param encoding Encoding to use if data is of type String. Default 'base64'
     * @returns
     */
    deserialize<T>(type: string, data: Uint8Array | string, encoding?: Encoding): T;
    /**
     * Safe method to register a custom Move struct. The first argument is a name of the
     * struct which is only used on the FrontEnd and has no affect on serialization results,
     * and the second is a struct description passed as an Object.
     *
     * The description object MUST have the same order on all of the platforms (ie in Move
     * or in Rust).
     *
     * @example
     * // Move struct
     * // struct Data {
     * //   num: u64,
     * //   str: std::string::String,
     * //   vec: vector<bool>,
     * // }
     *
     * const bcs = BCS.getInstance();
     *
     * bcs.registerStruct('data', {
     *   num: BCS.U64,
     *   str: BCS.STRING,
     *   vec: 'vector<bool>'
     * });
     *
     * const data = {
     *   num: 1234,
     *   str: '1234',
     *   vec: [true, false, true],
     * };
     *
     * const ser = bcs.serialize('data', data);
     * const de = bcs.deserialize('data', ser);
     *
     * @param name Name of the type to register.
     * @param fields Fields of the struct. Must be in the correct order.
     */
    registerStruct(name: string, fields: StructTypeDefinition): void;
    private registerOptionType;
}
export declare function argsEncodeWithABI(args: any[], abi: MoveFunctionABI): string[];
