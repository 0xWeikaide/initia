"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Validator = void 0;
const json_1 = require("../../util/json");
const Coins_1 = require("../Coins");
const num_1 = require("../num");
const PublicKey_1 = require("../PublicKey");
const staking_1 = require("@initia/initia.proto/initia/mstaking/v1/staking");
const long_1 = __importDefault(require("long"));
/**
 * Stores information fetched from the blockchain about the current status of a validator.
 * As an end user, you will not have to create an instance of this class, one will be
 * generated for you to store information about a validator polled from the API functions
 * in [[MstakingAPI]].
 */
class Validator extends json_1.JSONSerializable {
    /**
     *
     * @param operator_address validator's operator address
     * @param consensus_pubkey validator's consensus public key
     * @param jailed whether the current validator is jailed
     * @param status unbonded `0`, unbonding `1`, bonded `2`
     * @param tokens total Initia from all delegations (including self)
     * @param delegator_shares total shares of all delegators
     * @param description validator's delegate description
     * @param unbonding_height if unbonding, height at which this validator began unbonding
     * @param unbonding_time if unbonding, min time for the validator to complete unbonding
     * @param commission validator commission
     * @param min_self_delegation minimum self delegation
     */
    constructor(operator_address, consensus_pubkey, jailed, status, tokens, delegator_shares, description, unbonding_height, unbonding_time, commission, voting_powers, voting_power) {
        super();
        this.operator_address = operator_address;
        this.consensus_pubkey = consensus_pubkey;
        this.jailed = jailed;
        this.status = status;
        this.description = description;
        this.unbonding_height = unbonding_height;
        this.unbonding_time = unbonding_time;
        this.commission = commission;
        this.voting_power = voting_power;
        this.tokens = new Coins_1.Coins(tokens);
        this.delegator_shares = new Coins_1.Coins(delegator_shares);
        this.voting_powers = new Coins_1.Coins(voting_powers);
    }
    toAmino() {
        return {
            operator_address: this.operator_address,
            consensus_pubkey: this.consensus_pubkey.toAmino(),
            jailed: this.jailed,
            status: this.status,
            tokens: this.tokens.toAmino(),
            delegator_shares: this.delegator_shares.toAmino(),
            description: this.description,
            unbonding_height: this.unbonding_height.toFixed(),
            unbonding_time: this.unbonding_time.toISOString(),
            commission: this.commission.toAmino(),
            voting_powers: this.voting_powers.toAmino(),
            voting_power: this.voting_power,
        };
    }
    static fromAmino(data) {
        return new Validator(data.operator_address, PublicKey_1.ValConsPublicKey.fromAmino(data.consensus_pubkey), data.jailed || false, data.status || 0, Coins_1.Coins.fromAmino(data.tokens), Coins_1.Coins.fromAmino(data.delegator_shares), Validator.Description.fromAmino(data.description), Number.parseInt(data.unbonding_height), new Date(data.unbonding_time), Validator.Commission.fromAmino(data.commission), Coins_1.Coins.fromAmino(data.voting_powers), data.voting_power);
    }
    toData() {
        return {
            operator_address: this.operator_address,
            consensus_pubkey: this.consensus_pubkey.toData(),
            jailed: this.jailed,
            status: this.status,
            tokens: this.tokens.toData(),
            delegator_shares: this.delegator_shares.toData(),
            description: this.description,
            unbonding_height: this.unbonding_height.toFixed(),
            unbonding_time: this.unbonding_time.toISOString(),
            commission: this.commission.toData(),
            voting_powers: this.voting_powers.toData(),
            voting_power: this.voting_power,
        };
    }
    static fromData(data) {
        return new Validator(data.operator_address, PublicKey_1.ValConsPublicKey.fromData(data.consensus_pubkey), data.jailed || false, data.status || 0, Coins_1.Coins.fromData(data.tokens), Coins_1.Coins.fromData(data.delegator_shares), Validator.Description.fromData(data.description), Number.parseInt(data.unbonding_height), new Date(data.unbonding_time), Validator.Commission.fromData(data.commission), Coins_1.Coins.fromData(data.voting_powers), data.voting_power);
    }
    toProto() {
        const { operator_address, consensus_pubkey, jailed, status, tokens, delegator_shares, description, unbonding_height, unbonding_time, commission, voting_powers, voting_power, } = this;
        return staking_1.Validator.fromPartial({
            operatorAddress: operator_address,
            consensusPubkey: consensus_pubkey.packAny(),
            jailed,
            status,
            tokens: tokens.toProto(),
            delegatorShares: delegator_shares.toProto(),
            description: description.toProto(),
            unbondingHeight: long_1.default.fromNumber(unbonding_height),
            unbondingTime: unbonding_time,
            commission: commission.toProto(),
            votingPowers: voting_powers.toProto(),
            votingPower: voting_power,
        });
    }
    static fromProto(data) {
        return new Validator(data.operatorAddress, PublicKey_1.ValConsPublicKey.unpackAny(data.consensusPubkey), data.jailed, data.status, Coins_1.Coins.fromProto(data.tokens), Coins_1.Coins.fromProto(data.delegatorShares), Validator.Description.fromProto(data.description), data.unbondingHeight.toNumber(), data.unbondingTime, Validator.Commission.fromProto(data.commission), Coins_1.Coins.fromProto(data.votingPowers), data.votingPower);
    }
}
exports.Validator = Validator;
(function (Validator) {
    Validator.Status = staking_1.BondStatus;
    class Description extends json_1.JSONSerializable {
        /**
         * @param moniker Identifying name, e.g. "Hashed"
         * @param identity time at which commission was last updated
         * @param website validator's website
         * @param details long description
         * @param security_contact validator's contact
         */
        constructor(moniker, identity, website, details, security_contact) {
            super();
            this.moniker = moniker;
            this.identity = identity;
            this.website = website;
            this.details = details;
            this.security_contact = security_contact;
        }
        toAmino() {
            return {
                moniker: this.moniker,
                identity: this.identity,
                website: this.website,
                details: this.details,
                security_contact: this.security_contact,
            };
        }
        static fromAmino(data) {
            var _a, _b, _c, _d;
            return new Description(data.moniker, (_a = data.identity) !== null && _a !== void 0 ? _a : '', (_b = data.website) !== null && _b !== void 0 ? _b : '', (_c = data.details) !== null && _c !== void 0 ? _c : '', (_d = data.security_contact) !== null && _d !== void 0 ? _d : '');
        }
        toData() {
            return {
                moniker: this.moniker,
                identity: this.identity,
                website: this.website,
                details: this.details,
                security_contact: this.security_contact,
            };
        }
        static fromData(data) {
            var _a, _b, _c, _d;
            return new Description(data.moniker, (_a = data.identity) !== null && _a !== void 0 ? _a : '', (_b = data.website) !== null && _b !== void 0 ? _b : '', (_c = data.details) !== null && _c !== void 0 ? _c : '', (_d = data.security_contact) !== null && _d !== void 0 ? _d : '');
        }
        toProto() {
            const { moniker, identity, website, details, security_contact } = this;
            return staking_1.Description.fromPartial({
                details,
                identity,
                moniker,
                securityContact: security_contact,
                website,
            });
        }
        static fromProto(proto) {
            return new Description(proto.moniker, proto.identity, proto.website, proto.details, proto.securityContact);
        }
    }
    Validator.Description = Description;
    class CommissionRates extends json_1.JSONSerializable {
        /**
         * @param rate current commission rate
         * @param max_rate max commission rate
         * @param max_change_rate max percentage commission can change in 24hrs
         */
        constructor(rate, max_rate, max_change_rate) {
            super();
            this.rate = rate;
            this.max_rate = max_rate;
            this.max_change_rate = max_change_rate;
            this.rate = (0, num_1.num)(rate).toString();
            this.max_rate = (0, num_1.num)(max_rate).toString();
            this.max_change_rate = (0, num_1.num)(max_change_rate).toString();
        }
        static fromAmino(data) {
            const { rate, max_rate, max_change_rate } = data;
            return new CommissionRates(rate, max_rate, max_change_rate);
        }
        toAmino() {
            const { rate, max_rate, max_change_rate } = this;
            return {
                rate,
                max_rate,
                max_change_rate,
            };
        }
        static fromData(data) {
            const { rate, max_rate, max_change_rate } = data;
            return new CommissionRates(rate, max_rate, max_change_rate);
        }
        toData() {
            const { rate, max_rate, max_change_rate } = this;
            return {
                rate,
                max_rate,
                max_change_rate,
            };
        }
        static fromProto(proto) {
            return new CommissionRates(proto.rate, proto.maxRate, proto.maxChangeRate);
        }
        toProto() {
            const { rate, max_rate, max_change_rate } = this;
            return staking_1.CommissionRates.fromPartial({
                maxChangeRate: max_change_rate,
                maxRate: max_rate,
                rate,
            });
        }
    }
    Validator.CommissionRates = CommissionRates;
    class Commission extends json_1.JSONSerializable {
        /**
         * @param commission_rates commission rates
         * @param update_time time at which commission was last updated
         */
        constructor(commission_rates, update_time) {
            super();
            this.commission_rates = commission_rates;
            this.update_time = update_time;
        }
        toAmino() {
            return {
                commission_rates: this.commission_rates.toAmino(),
                update_time: this.update_time.toISOString(),
            };
        }
        static fromAmino(data) {
            return new Commission(CommissionRates.fromAmino(data.commission_rates), new Date(data.update_time));
        }
        toData() {
            return {
                commission_rates: this.commission_rates.toData(),
                update_time: this.update_time.toISOString(),
            };
        }
        static fromData(data) {
            return new Commission(CommissionRates.fromData(data.commission_rates), new Date(data.update_time));
        }
        toProto() {
            const { commission_rates, update_time } = this;
            return staking_1.Commission.fromPartial({
                commissionRates: commission_rates.toProto(),
                updateTime: update_time,
            });
        }
        static fromProto(proto) {
            return new Commission(CommissionRates.fromProto(proto.commissionRates), proto.updateTime);
        }
    }
    Validator.Commission = Commission;
})(Validator || (exports.Validator = Validator = {}));
//# sourceMappingURL=Validator.js.map