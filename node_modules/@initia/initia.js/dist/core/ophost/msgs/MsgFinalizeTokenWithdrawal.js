"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsgFinalizeTokenWithdrawal = void 0;
const json_1 = require("../../../util/json");
const Coin_1 = require("../../Coin");
const tx_1 = require("@initia/opinit.proto/opinit/ophost/v1/tx");
const any_1 = require("@initia/initia.proto/google/protobuf/any");
const long_1 = __importDefault(require("long"));
class MsgFinalizeTokenWithdrawal extends json_1.JSONSerializable {
    /**
     * @param bridge_id
     * @param output_index
     * @param withdrawal_proofs
     * @param sender
     * @param receiver
     * @param sequence
     * @param amount
     * @param version
     * @param state_root
     * @param storage_root
     * @param latest_block_hash
     */
    constructor(bridge_id, output_index, withdrawal_proofs, sender, receiver, sequence, amount, version, state_root, storage_root, latest_block_hash) {
        super();
        this.bridge_id = bridge_id;
        this.output_index = output_index;
        this.withdrawal_proofs = withdrawal_proofs;
        this.sender = sender;
        this.receiver = receiver;
        this.sequence = sequence;
        this.amount = amount;
        this.version = version;
        this.state_root = state_root;
        this.storage_root = storage_root;
        this.latest_block_hash = latest_block_hash;
    }
    static fromAmino(data) {
        const { value: { bridge_id, output_index, withdrawal_proofs, sender, receiver, sequence, amount, version, state_root, storage_root, latest_block_hash, }, } = data;
        return new MsgFinalizeTokenWithdrawal(Number.parseInt(bridge_id), Number.parseInt(output_index), withdrawal_proofs, sender, receiver, Number.parseInt(sequence), Coin_1.Coin.fromAmino(amount), version, state_root, storage_root, latest_block_hash);
    }
    toAmino() {
        const { bridge_id, output_index, withdrawal_proofs, sender, receiver, sequence, amount, version, state_root, storage_root, latest_block_hash, } = this;
        return {
            type: 'ophost/MsgFinalizeTokenWithdrawal',
            value: {
                bridge_id: bridge_id.toString(),
                output_index: output_index.toString(),
                withdrawal_proofs,
                sender,
                receiver,
                sequence: sequence.toString(),
                amount: amount.toAmino(),
                version,
                state_root,
                storage_root,
                latest_block_hash,
            },
        };
    }
    static fromData(data) {
        const { bridge_id, output_index, withdrawal_proofs, sender, receiver, sequence, amount, version, state_root, storage_root, latest_block_hash, } = data;
        return new MsgFinalizeTokenWithdrawal(Number.parseInt(bridge_id), Number.parseInt(output_index), withdrawal_proofs, sender, receiver, Number.parseInt(sequence), Coin_1.Coin.fromData(amount), version, state_root, storage_root, latest_block_hash);
    }
    toData() {
        const { bridge_id, output_index, withdrawal_proofs, sender, receiver, sequence, amount, version, state_root, storage_root, latest_block_hash, } = this;
        return {
            '@type': '/opinit.ophost.v1.MsgFinalizeTokenWithdrawal',
            bridge_id: bridge_id.toString(),
            output_index: output_index.toString(),
            withdrawal_proofs,
            sender,
            receiver,
            sequence: sequence.toString(),
            amount: amount.toData(),
            version,
            state_root,
            storage_root,
            latest_block_hash,
        };
    }
    static fromProto(data) {
        return new MsgFinalizeTokenWithdrawal(data.bridgeId.toNumber(), data.outputIndex.toNumber(), data.withdrawalProofs.map(proof => Buffer.from(proof).toString('base64')), data.sender, data.receiver, data.sequence.toNumber(), Coin_1.Coin.fromProto(data.amount), Buffer.from(data.version).toString('base64'), Buffer.from(data.stateRoot).toString('base64'), Buffer.from(data.storageRoot).toString('base64'), Buffer.from(data.latestBlockHash).toString('base64'));
    }
    toProto() {
        const { bridge_id, output_index, withdrawal_proofs, sender, receiver, sequence, amount, version, state_root, storage_root, latest_block_hash, } = this;
        return tx_1.MsgFinalizeTokenWithdrawal.fromPartial({
            bridgeId: long_1.default.fromNumber(bridge_id),
            outputIndex: long_1.default.fromNumber(output_index),
            withdrawalProofs: withdrawal_proofs.map(proof => Buffer.from(proof, 'base64')),
            sender,
            receiver,
            sequence: long_1.default.fromNumber(sequence),
            amount: amount.toProto(),
            version: Buffer.from(version, 'base64'),
            stateRoot: Buffer.from(state_root, 'base64'),
            storageRoot: Buffer.from(storage_root, 'base64'),
            latestBlockHash: Buffer.from(latest_block_hash, 'base64'),
        });
    }
    packAny() {
        return any_1.Any.fromPartial({
            typeUrl: '/opinit.ophost.v1.MsgFinalizeTokenWithdrawal',
            value: tx_1.MsgFinalizeTokenWithdrawal.encode(this.toProto()).finish(),
        });
    }
    static unpackAny(msgAny) {
        return MsgFinalizeTokenWithdrawal.fromProto(tx_1.MsgFinalizeTokenWithdrawal.decode(msgAny.value));
    }
}
exports.MsgFinalizeTokenWithdrawal = MsgFinalizeTokenWithdrawal;
//# sourceMappingURL=MsgFinalizeTokenWithdrawal.js.map