import { JSONSerializable } from '../../../util/json';
import { AccAddress } from '../../bech32';
import { Any } from '@initia/initia.proto/google/protobuf/any';
import { MsgPayForBlobs as MsgPayForBlobs_pb } from '@initia/initia.proto/celestia/blob/v1/tx';
export declare class MsgPayForBlobs extends JSONSerializable<any, MsgPayForBlobs.Data, MsgPayForBlobs.Proto> {
    signer: AccAddress;
    namespaces: string[];
    blob_sizes: number[];
    share_commitments: string[];
    share_versions: number[];
    /**
     * @param signer the bech32 encoded signer address
     * @param namespaces list of namespaces that the blobs are associated with
     * @param blob_sizes list of blob sizes (one per blob) in bytes
     * @param share_commitments list of share commitments (one per blob)
     * @param share_versions the versions of the share format that the blobs should use when included in a block
     */
    constructor(signer: AccAddress, namespaces: string[], blob_sizes: number[], share_commitments: string[], share_versions: number[]);
    static fromAmino(_: any): MsgPayForBlobs;
    toAmino(): any;
    static fromData(data: MsgPayForBlobs.Data): MsgPayForBlobs;
    toData(): MsgPayForBlobs.Data;
    static fromProto(data: MsgPayForBlobs.Proto): MsgPayForBlobs;
    toProto(): MsgPayForBlobs.Proto;
    packAny(): Any;
    static unpackAny(msgAny: Any): MsgPayForBlobs;
}
export declare namespace MsgPayForBlobs {
    interface Data {
        '@type': '/celestia.blob.v1.MsgPayForBlobs';
        signer: AccAddress;
        namespaces: string[];
        blob_sizes: string[];
        share_commitments: string[];
        share_versions: string[];
    }
    type Proto = MsgPayForBlobs_pb;
}
