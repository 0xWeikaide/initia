"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsgPayForBlobs = void 0;
const json_1 = require("../../../util/json");
const any_1 = require("@initia/initia.proto/google/protobuf/any");
const tx_1 = require("@initia/initia.proto/celestia/blob/v1/tx");
class MsgPayForBlobs extends json_1.JSONSerializable {
    /**
     * @param signer the bech32 encoded signer address
     * @param namespaces list of namespaces that the blobs are associated with
     * @param blob_sizes list of blob sizes (one per blob) in bytes
     * @param share_commitments list of share commitments (one per blob)
     * @param share_versions the versions of the share format that the blobs should use when included in a block
     */
    constructor(signer, namespaces, blob_sizes, share_commitments, share_versions) {
        super();
        this.signer = signer;
        this.namespaces = namespaces;
        this.blob_sizes = blob_sizes;
        this.share_commitments = share_commitments;
        this.share_versions = share_versions;
    }
    static fromAmino(_) {
        _;
        throw new Error('Amino not supported');
    }
    toAmino() {
        throw new Error('Amino not supported');
    }
    static fromData(data) {
        const { signer, namespaces, blob_sizes, share_commitments, share_versions, } = data;
        return new MsgPayForBlobs(signer, namespaces, blob_sizes.map(Number.parseInt), share_commitments, share_versions.map(Number.parseInt));
    }
    toData() {
        const { signer, namespaces, blob_sizes, share_commitments, share_versions, } = this;
        return {
            '@type': '/celestia.blob.v1.MsgPayForBlobs',
            signer,
            namespaces,
            blob_sizes: blob_sizes.map(size => size.toString()),
            share_commitments,
            share_versions: share_versions.map(version => version.toString()),
        };
    }
    static fromProto(data) {
        return new MsgPayForBlobs(data.signer, data.namespaces.map(namespace => Buffer.from(namespace).toString('base64')), data.blobSizes, data.shareCommitments.map(commitment => Buffer.from(commitment).toString('base64')), data.shareVersions);
    }
    toProto() {
        const { signer, namespaces, blob_sizes, share_commitments, share_versions, } = this;
        return tx_1.MsgPayForBlobs.fromPartial({
            signer,
            namespaces: namespaces.map(namespace => Buffer.from(namespace, 'base64')),
            blobSizes: blob_sizes,
            shareCommitments: share_commitments.map(commitment => Buffer.from(commitment, 'base64')),
            shareVersions: share_versions,
        });
    }
    packAny() {
        return any_1.Any.fromPartial({
            typeUrl: '/celestia.blob.v1.MsgPayForBlobs',
            value: tx_1.MsgPayForBlobs.encode(this.toProto()).finish(),
        });
    }
    static unpackAny(msgAny) {
        return MsgPayForBlobs.fromProto(tx_1.MsgPayForBlobs.decode(msgAny.value));
    }
}
exports.MsgPayForBlobs = MsgPayForBlobs;
//# sourceMappingURL=MsgPayForBlobs.js.map