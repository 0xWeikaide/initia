"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlobTx = void 0;
const json_1 = require("../../util/json");
const Tx_1 = require("../tx/Tx");
const Blob_1 = require("./Blob");
const blob_1 = require("@initia/initia.proto/celestia/blob/v1/blob");
class BlobTx extends json_1.JSONSerializable {
    /**
     * @param tx
     * @param blobs
     * @param type_id
     */
    constructor(tx, blobs, type_id) {
        super();
        this.tx = tx;
        this.blobs = blobs;
        this.type_id = type_id;
    }
    static fromAmino(_) {
        _;
        throw new Error('Amino not supported');
    }
    toAmino() {
        throw new Error('Amino not supported');
    }
    static fromData(data) {
        const { tx, blobs, type_id } = data;
        return new BlobTx(Tx_1.Tx.fromData(tx), blobs.map(Blob_1.Blob.fromData), type_id);
    }
    toData() {
        const { tx, blobs, type_id } = this;
        return {
            tx: tx.toData(),
            blobs: blobs.map(blob => blob.toData()),
            type_id,
        };
    }
    static fromProto(data) {
        return new BlobTx(Tx_1.Tx.fromBuffer(Buffer.from(data.tx)), data.blobs.map(Blob_1.Blob.fromProto), data.typeId);
    }
    toProto() {
        const { tx, blobs, type_id } = this;
        return blob_1.BlobTx.fromPartial({
            tx: tx.toBytes(),
            blobs: blobs.map(blob => blob.toProto()),
            typeId: type_id,
        });
    }
    toBytes() {
        return blob_1.BlobTx.encode(this.toProto()).finish();
    }
}
exports.BlobTx = BlobTx;
//# sourceMappingURL=BlobTx.js.map