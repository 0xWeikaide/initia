"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Allocation = void 0;
const json_1 = require("../../../../../util/json");
const Coins_1 = require("../../../../Coins");
const authz_1 = require("@initia/initia.proto/ibc/applications/transfer/v1/authz");
class Allocation extends json_1.JSONSerializable {
    /**
     * @param source_port the port on which the packet will be sent
     * @param source_channel the channel by which the packet will be sent
     * @param spend_limit spend limitation on the channel
     * @param allow_list allow list of receivers, an empty allow list permits any receiver address
     * @param allowed_packet_data allow list of packet data keys, an empty list prohibits all packet data keys
     */
    constructor(source_port, source_channel, spend_limit, allow_list, allowed_packet_data) {
        super();
        this.source_port = source_port;
        this.source_channel = source_channel;
        this.allow_list = allow_list;
        this.allowed_packet_data = allowed_packet_data;
        this.spend_limit = new Coins_1.Coins(spend_limit);
    }
    static fromAmino(data) {
        const { source_port, source_channel, spend_limit, allow_list, allowed_packet_data, } = data;
        return new Allocation(source_port, source_channel, Coins_1.Coins.fromAmino(spend_limit), allow_list, allowed_packet_data);
    }
    toAmino() {
        const { source_port, source_channel, spend_limit, allow_list, allowed_packet_data, } = this;
        return {
            source_port,
            source_channel,
            spend_limit: spend_limit.toAmino(),
            allow_list,
            allowed_packet_data,
        };
    }
    static fromData(data) {
        const { source_port, source_channel, spend_limit, allow_list, allowed_packet_data, } = data;
        return new Allocation(source_port, source_channel, Coins_1.Coins.fromData(spend_limit), allow_list, allowed_packet_data);
    }
    toData() {
        const { source_port, source_channel, spend_limit, allow_list, allowed_packet_data, } = this;
        return {
            source_port,
            source_channel,
            spend_limit: spend_limit.toData(),
            allow_list,
            allowed_packet_data,
        };
    }
    static fromProto(data) {
        return new Allocation(data.sourcePort, data.sourceChannel, Coins_1.Coins.fromProto(data.spendLimit), data.allowList, data.allowedPacketData);
    }
    toProto() {
        const { source_port, source_channel, spend_limit, allow_list, allowed_packet_data, } = this;
        return authz_1.Allocation.fromPartial({
            sourcePort: source_port,
            sourceChannel: source_channel,
            spendLimit: spend_limit.toProto(),
            allowList: allow_list,
            allowedPacketData: allowed_packet_data,
        });
    }
}
exports.Allocation = Allocation;
//# sourceMappingURL=Allocation.js.map