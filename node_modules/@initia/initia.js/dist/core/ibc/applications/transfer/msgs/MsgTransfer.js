"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsgTransfer = void 0;
const json_1 = require("../../../../../util/json");
const Coin_1 = require("../../../../Coin");
const long_1 = __importDefault(require("long"));
const any_1 = require("@initia/initia.proto/google/protobuf/any");
const tx_1 = require("@initia/initia.proto/ibc/applications/transfer/v1/tx");
const Height_1 = require("../../../core/client/Height");
/**
 * A basic message for transfer [[Coin]] via IBC.
 */
class MsgTransfer extends json_1.JSONSerializable {
    /**
     * @param source_port the port on which the packet will be sent
     * @param source_channel  the channel by which the packet will be sent
     * @param token the tokens to be transferred
     * @param sender the sender address
     * @param receiver the recipient address on the destination chain
     * @param timeout_height Timeout height relative to the current block height. (0 to disable)
     * @param timeout_timestamp Timeout timestamp (in nanoseconds) relative to the current block timestamp. (0 to disable)
     * @param memo optional memo
     */
    constructor(source_port, source_channel, token, sender, receiver, timeout_height, timeout_timestamp, memo) {
        super();
        if (!timeout_height && !timeout_timestamp) {
            throw new Error('both of timeout_height and timeout_timestamp are undefined');
        }
        this.source_port = source_port;
        this.source_channel = source_channel;
        this.token = token;
        this.sender = sender;
        this.receiver = receiver;
        this.timeout_height = timeout_height;
        this.timeout_timestamp = timeout_timestamp;
        this.memo = memo;
    }
    static fromAmino(data) {
        const { value: { source_port, source_channel, token, sender, receiver, timeout_height, timeout_timestamp, memo, }, } = data;
        if (!timeout_height && !timeout_timestamp) {
            throw new Error('both of timeout_height and timeout_timestamp are undefined');
        }
        return new MsgTransfer(source_port, source_channel, token ? Coin_1.Coin.fromAmino(token) : undefined, sender, receiver, timeout_height ? Height_1.Height.fromAmino(timeout_height) : undefined, timeout_timestamp, memo);
    }
    toAmino() {
        var _a;
        const { source_port, source_channel, token, sender, receiver, timeout_height, timeout_timestamp, memo, } = this;
        return {
            type: 'cosmos-sdk/MsgTransfer',
            value: {
                source_port,
                source_channel,
                token: token === null || token === void 0 ? void 0 : token.toAmino(),
                sender,
                receiver,
                timeout_height: (_a = timeout_height === null || timeout_height === void 0 ? void 0 : timeout_height.toAmino()) !== null && _a !== void 0 ? _a : {},
                timeout_timestamp,
                memo,
            },
        };
    }
    static fromData(data) {
        const { source_port, source_channel, token, sender, receiver, timeout_timestamp, timeout_height, memo, } = data;
        if (!timeout_height && !timeout_timestamp) {
            throw new Error('both of timeout_height and timeout_timestamp are undefined');
        }
        return new MsgTransfer(source_port, source_channel, token ? Coin_1.Coin.fromData(token) : undefined, sender, receiver, timeout_height ? Height_1.Height.fromData(timeout_height) : undefined, timeout_timestamp === '0' ? undefined : timeout_timestamp, memo);
    }
    toData() {
        const { source_port, source_channel, token, sender, receiver, timeout_height, timeout_timestamp, memo, } = this;
        return {
            '@type': '/ibc.applications.transfer.v1.MsgTransfer',
            source_port,
            source_channel,
            token: token === null || token === void 0 ? void 0 : token.toData(),
            sender,
            receiver,
            timeout_height: timeout_height
                ? timeout_height.toData()
                : new Height_1.Height(0, 0).toData(),
            timeout_timestamp: timeout_timestamp !== null && timeout_timestamp !== void 0 ? timeout_timestamp : '0',
            memo,
        };
    }
    static fromProto(proto) {
        if (!proto.timeoutHeight && proto.timeoutTimestamp.toNumber() == 0) {
            throw new Error('both of timeout_height and timeout_timestamp are empty');
        }
        return new MsgTransfer(proto.sourcePort, proto.sourceChannel, proto.token ? Coin_1.Coin.fromProto(proto.token) : undefined, proto.sender, proto.receiver, proto.timeoutHeight ? Height_1.Height.fromProto(proto.timeoutHeight) : undefined, proto.timeoutTimestamp.toString(), proto.memo);
    }
    toProto() {
        const { source_port, source_channel, token, sender, receiver, timeout_height, timeout_timestamp, memo, } = this;
        return tx_1.MsgTransfer.fromPartial({
            sourcePort: source_port,
            sourceChannel: source_channel,
            token: token === null || token === void 0 ? void 0 : token.toProto(),
            sender,
            receiver,
            timeoutHeight: timeout_height === null || timeout_height === void 0 ? void 0 : timeout_height.toProto(),
            timeoutTimestamp: long_1.default.fromString(timeout_timestamp !== null && timeout_timestamp !== void 0 ? timeout_timestamp : '0'),
            memo,
        });
    }
    packAny() {
        return any_1.Any.fromPartial({
            typeUrl: '/ibc.applications.transfer.v1.MsgTransfer',
            value: tx_1.MsgTransfer.encode(this.toProto()).finish(),
        });
    }
    static unpackAny(msgAny) {
        return MsgTransfer.fromProto(tx_1.MsgTransfer.decode(msgAny.value));
    }
}
exports.MsgTransfer = MsgTransfer;
//# sourceMappingURL=MsgTransfer.js.map