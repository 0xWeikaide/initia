"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsgNftTransfer = void 0;
const json_1 = require("../../../../../util/json");
const long_1 = __importDefault(require("long"));
const any_1 = require("@initia/initia.proto/google/protobuf/any");
const tx_1 = require("@initia/initia.proto/ibc/applications/nft_transfer/v1/tx");
const Height_1 = require("../../../core/client/Height");
/**
 * A basic message for NFT transfer via IBC.
 */
class MsgNftTransfer extends json_1.JSONSerializable {
    /**
     * @param source_port the port on which the packet will be sent
     * @param source_channel the channel by which the packet will be sent
     * @param class_id the struct tag of the extension
     * @param token_ids the token ids of the NFT
     * @param sender the sender address
     * @param receiver the recipient address on the destination chain
     * @param timeout_height Timeout height relative to the current block height. (0 to disable)
     * @param timeout_timestamp Timeout timestamp (in nanoseconds) relative to the current block timestamp. (0 to disable)
     * @param memo optional memo
     */
    constructor(source_port, source_channel, class_id, token_ids, sender, receiver, timeout_height, timeout_timestamp, memo) {
        super();
        if (!timeout_height && !timeout_timestamp) {
            throw new Error('both of timeout_height and timeout_timestamp are undefined');
        }
        this.source_port = source_port;
        this.source_channel = source_channel;
        this.class_id = class_id;
        this.token_ids = token_ids;
        this.sender = sender;
        this.receiver = receiver;
        this.timeout_height = timeout_height;
        this.timeout_timestamp = timeout_timestamp;
        this.memo = memo;
    }
    static fromAmino(data) {
        const { value: { source_port, source_channel, class_id, token_ids, sender, receiver, timeout_height, timeout_timestamp, memo, }, } = data;
        if (!timeout_height && !timeout_timestamp) {
            throw new Error('both of timeout_height and timeout_timestamp are undefined');
        }
        return new MsgNftTransfer(source_port, source_channel, class_id, token_ids, sender, receiver, timeout_height ? Height_1.Height.fromAmino(timeout_height) : undefined, timeout_timestamp, memo);
    }
    toAmino() {
        var _a;
        const { source_port, source_channel, class_id, token_ids, sender, receiver, timeout_height, timeout_timestamp, memo, } = this;
        return {
            type: 'nft-transfer/MsgTransfer',
            value: {
                source_port,
                source_channel,
                class_id,
                token_ids,
                sender,
                receiver,
                timeout_height: (_a = timeout_height === null || timeout_height === void 0 ? void 0 : timeout_height.toAmino()) !== null && _a !== void 0 ? _a : {},
                timeout_timestamp,
                memo,
            },
        };
    }
    static fromData(data) {
        const { source_port, source_channel, class_id, token_ids, sender, receiver, timeout_timestamp, timeout_height, memo, } = data;
        if (!timeout_height && !timeout_timestamp) {
            throw new Error('both of timeout_height and timeout_timestamp are undefined');
        }
        return new MsgNftTransfer(source_port, source_channel, class_id, token_ids, sender, receiver, timeout_height ? Height_1.Height.fromData(timeout_height) : undefined, timeout_timestamp === '0' ? undefined : timeout_timestamp, memo);
    }
    toData() {
        const { source_port, source_channel, class_id, token_ids, sender, receiver, timeout_height, timeout_timestamp, memo, } = this;
        return {
            '@type': '/ibc.applications.nft_transfer.v1.MsgTransfer',
            source_port,
            source_channel,
            class_id,
            token_ids,
            sender,
            receiver,
            timeout_height: timeout_height
                ? timeout_height.toData()
                : new Height_1.Height(0, 0).toData(),
            timeout_timestamp: timeout_timestamp !== null && timeout_timestamp !== void 0 ? timeout_timestamp : '0',
            memo,
        };
    }
    static fromProto(proto) {
        if (!proto.timeoutHeight && proto.timeoutTimestamp.toNumber() == 0) {
            throw new Error('both of timeout_height and timeout_timestamp are empty');
        }
        return new MsgNftTransfer(proto.sourcePort, proto.sourceChannel, proto.classId, proto.tokenIds, proto.sender, proto.receiver, proto.timeoutHeight ? Height_1.Height.fromProto(proto.timeoutHeight) : undefined, proto.timeoutTimestamp.toString(), proto.memo);
    }
    toProto() {
        const { source_port, source_channel, class_id, token_ids, sender, receiver, timeout_height, timeout_timestamp, memo, } = this;
        return tx_1.MsgTransfer.fromPartial({
            sourcePort: source_port,
            sourceChannel: source_channel,
            classId: class_id,
            tokenIds: token_ids,
            sender,
            receiver,
            timeoutHeight: timeout_height === null || timeout_height === void 0 ? void 0 : timeout_height.toProto(),
            timeoutTimestamp: long_1.default.fromString(timeout_timestamp !== null && timeout_timestamp !== void 0 ? timeout_timestamp : '0'),
            memo,
        });
    }
    packAny() {
        return any_1.Any.fromPartial({
            typeUrl: '/ibc.applications.nft_transfer.v1.MsgTransfer',
            value: tx_1.MsgTransfer.encode(this.toProto()).finish(),
        });
    }
    static unpackAny(msgAny) {
        return MsgNftTransfer.fromProto(tx_1.MsgTransfer.decode(msgAny.value));
    }
}
exports.MsgNftTransfer = MsgNftTransfer;
//# sourceMappingURL=MsgNftTransfer.js.map