"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonFungibleTokenPacketData = void 0;
const packet_1 = require("@initia/initia.proto/ibc/applications/nft_transfer/v1/packet");
const json_1 = require("../../../../util/json");
/**
 *  NonFungibleTokenPacketData defines a struct for the packet payload
 * See NonFungibleTokenPacketData spec:
 * https://github.com/cosmos/ibc/tree/main/spec/app/ics-721-nft-transfer
 */
class NonFungibleTokenPacketData extends json_1.JSONSerializable {
    /**
     * @param class_id collection id == extension struct tag
     * @param class_uri collection url
     * @param class_data collection data
     * @param token_ids nft token ids
     * @param token_uris nft token uris
     * @param token_data nft token data array
     * @param sender sender of nft
     * @param receiver receiver of nft
     * @param memo optional memo field for future use
     */
    constructor(class_id, class_uri, class_data, token_ids, token_uris, token_data, sender, receiver, memo) {
        super();
        this.class_id = class_id;
        this.class_uri = class_uri;
        this.class_data = class_data;
        this.token_ids = token_ids;
        this.token_uris = token_uris;
        this.token_data = token_data;
        this.sender = sender;
        this.receiver = receiver;
        this.memo = memo;
    }
    static fromAmino(data) {
        const { class_id, class_uri, class_data, token_ids, token_uris, token_data, sender, receiver, memo, } = data;
        return new NonFungibleTokenPacketData(class_id, class_uri, class_data, token_ids, token_uris, token_data, sender, receiver, memo);
    }
    toAmino() {
        const { class_id, class_uri, class_data, token_ids, token_uris, token_data, sender, receiver, memo, } = this;
        return {
            class_id,
            class_uri,
            class_data,
            token_ids,
            token_uris,
            token_data,
            sender,
            receiver,
            memo,
        };
    }
    static fromData(data) {
        const { class_id, class_uri, class_data, token_ids, token_uris, token_data, sender, receiver, memo, } = data;
        return new NonFungibleTokenPacketData(class_id, class_uri, class_data, token_ids, token_uris, token_data, sender, receiver, memo);
    }
    toData() {
        const { class_id, class_uri, class_data, token_ids, token_uris, token_data, sender, receiver, memo, } = this;
        return {
            class_id,
            class_uri,
            class_data,
            token_ids,
            token_uris,
            token_data,
            sender,
            receiver,
            memo,
        };
    }
    static fromProto(proto) {
        return new NonFungibleTokenPacketData(proto.classId, proto.classUri, proto.classData, proto.tokenIds, proto.tokenUris, proto.tokenData, proto.sender, proto.receiver, proto.memo);
    }
    toProto() {
        const { class_id, class_uri, class_data, token_ids, token_uris, token_data, sender, receiver, memo, } = this;
        return packet_1.NonFungibleTokenPacketData.fromPartial({
            classId: class_id,
            classUri: class_uri,
            classData: class_data,
            tokenIds: token_ids,
            tokenUris: token_uris,
            tokenData: token_data,
            sender,
            receiver,
            memo,
        });
    }
}
exports.NonFungibleTokenPacketData = NonFungibleTokenPacketData;
//# sourceMappingURL=NonFungibleTokenPacketData.js.map