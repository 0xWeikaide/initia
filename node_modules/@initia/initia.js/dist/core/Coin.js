"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Coin = void 0;
const json_1 = require("../util/json");
const num_1 = require("./num");
const coin_1 = require("@initia/initia.proto/cosmos/base/v1beta1/coin");
/**
 * Captures `sdk.Coin` and `sdk.DecCoin` from Cosmos SDK. A composite value that combines
 * a denomination with an amount value. Coins are immutable once created, and operations
 * that return Coin will return a new Coin. See [[Coins]] for a collection of Coin objects.
 */
class Coin extends json_1.JSONSerializable {
    /**
     * Creates a new coin. Depending on the type of amount, it will be converted to an
     * integer coin or decimal coin.
     *
     * @param denom denomination
     * @param amount coin's amount
     */
    constructor(denom, amount) {
        super();
        this.denom = denom;
        this.amount = (0, num_1.num)(amount).toString();
        this.isDecimal = (0, num_1.checkDecimal)(amount);
    }
    /**
     * Turns the Coin into an Integer coin.
     */
    toIntCoin() {
        return new Coin(this.denom, (0, num_1.num)(this.amount).toFixed(0));
    }
    /**
     * Turns the Coin into an Integer coin with ceiling the amount.
     */
    toIntCeilCoin() {
        return new Coin(this.denom, (0, num_1.num)(this.amount).toFixed(0, 2));
    }
    /**
     * Turns the Coin into a Decimal coin.
     */
    toDecCoin() {
        return new Coin(this.denom, this.amount.includes('.') ? this.amount : (0, num_1.num)(this.amount).toFixed(1));
    }
    /**
     * Outputs `<amount><denom>`.
     *
     * Eg: `Coin('uinit', 1500) -> 1500uinit`
     */
    toString() {
        const amount = this.isDecimal && !this.amount.includes('.')
            ? (0, num_1.num)(this.amount).toFixed(1)
            : (0, num_1.num)(this.amount).toFixed();
        return `${amount}${this.denom}`;
    }
    static fromString(str) {
        const m = str.match(/^(-?[0-9]+(\.[0-9]+)?)([0-9a-zA-Z/]+)$/);
        if (m === null) {
            throw new Error(`failed to parse to Coin: ${str}`);
        }
        const amount = m[1];
        const denom = m[3];
        return new Coin(denom, amount);
    }
    /**
     * Creates a new Coin adding to the current value.
     *
     * @param other
     */
    add(other) {
        let otherAmount;
        let isDecimal = this.isDecimal;
        if (other instanceof Coin) {
            if (other.denom !== this.denom) {
                throw new Coin.ArithmeticError(`cannot add two Coins of different denoms: ${this.denom} and ${other.denom}`);
            }
            otherAmount = other.amount;
            isDecimal = isDecimal || other.isDecimal;
        }
        else {
            otherAmount = other;
            isDecimal = isDecimal || (0, num_1.checkDecimal)(other);
        }
        const res = (0, num_1.num)(this.amount).plus(otherAmount);
        return new Coin(this.denom, isDecimal && res.isInteger() ? res.toFixed(1) : res.toFixed());
    }
    /**
     * Creates a new Coin subtracting from the current value.
     * @param other
     */
    sub(other) {
        let otherAmount;
        let isDecimal = this.isDecimal;
        if (other instanceof Coin) {
            if (other.denom !== this.denom) {
                throw new Coin.ArithmeticError(`cannot subtract two Coins of different denoms: ${this.denom} and ${other.denom}`);
            }
            otherAmount = other.amount;
            isDecimal = isDecimal || other.isDecimal;
        }
        else {
            otherAmount = other;
            isDecimal = isDecimal || (0, num_1.checkDecimal)(other);
        }
        const res = (0, num_1.num)(this.amount).minus(otherAmount);
        return new Coin(this.denom, isDecimal && res.isInteger() ? res.toFixed(1) : res.toFixed());
    }
    /**
     * Multiplies the current value with an amount.
     * @param other
     */
    mul(other) {
        const isDecimal = this.isDecimal || (0, num_1.checkDecimal)(other);
        const res = (0, num_1.num)(this.amount).multipliedBy(other);
        return new Coin(this.denom, isDecimal && res.isInteger() ? res.toFixed(1) : res.toFixed());
    }
    /**
     * Divides the current value with an amount.
     * @param other
     */
    div(other) {
        const isDecimal = this.isDecimal || (0, num_1.checkDecimal)(other);
        const res = (0, num_1.num)(this.amount).dividedBy(other);
        return new Coin(this.denom, isDecimal && res.isInteger() ? res.toFixed(1) : res.toFixed());
    }
    /**
     * Modulo the current value with an amount.
     * @param other
     */
    mod(other) {
        const isDecimal = this.isDecimal || (0, num_1.checkDecimal)(other);
        const res = (0, num_1.num)(this.amount).mod(other);
        return new Coin(this.denom, isDecimal && res.isInteger() ? res.toFixed(1) : res.toFixed());
    }
    static fromAmino(data) {
        const { denom, amount } = data;
        return new Coin(denom, amount);
    }
    toAmino() {
        const { denom, amount } = this;
        return {
            denom,
            amount: this.isDecimal ? (0, num_1.num)(amount).toFixed(18) : amount,
        };
    }
    static fromData(data) {
        const { denom, amount } = data;
        return new Coin(denom, amount);
    }
    toData() {
        const { denom, amount } = this;
        return {
            denom,
            amount: this.isDecimal ? (0, num_1.num)(amount).toFixed(18) : amount,
        };
    }
    static fromProto(proto) {
        return new Coin(proto.denom, proto.amount);
    }
    toProto() {
        return coin_1.Coin.fromPartial({
            denom: this.denom,
            amount: this.isDecimal ? (0, num_1.num)(this.amount).toFixed(18) : this.amount,
        });
    }
}
exports.Coin = Coin;
(function (Coin) {
    class ArithmeticError {
        constructor(message) {
            this.message = message;
        }
    }
    Coin.ArithmeticError = ArithmeticError;
})(Coin || (exports.Coin = Coin = {}));
//# sourceMappingURL=Coin.js.map