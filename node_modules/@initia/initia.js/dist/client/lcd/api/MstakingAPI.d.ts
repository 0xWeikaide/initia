import { AccAddress, ValAddress, UnbondingDelegation, Coins, Delegation, Validator, Redelegation, MstakingParams } from '../../../core';
import { BaseAPI } from './BaseAPI';
import { APIParams, Pagination, PaginationOptions } from '../APIRequester';
export interface MstakingPool {
    /** amount of tokens are bonded, including those that are currently unbonding */
    bonded_tokens: Coins;
    /** amount of tokens that are not bonded */
    not_bonded_tokens: Coins;
}
export declare namespace MstakingPool {
    interface Data {
        bonded_tokens: Coins.Data;
        not_bonded_tokens: Coins.Data;
    }
}
export declare class MstakingAPI extends BaseAPI {
    /**
     * Queries all delegations, filtering by delegator, validator, or both.
     *
     * At least one of the parameters must be defined.
     * @param delegator delegator's account address
     * @param validator validator's operator address
     */
    delegations(delegator?: AccAddress, validator?: ValAddress, params?: Partial<PaginationOptions & APIParams>): Promise<[Delegation[], Pagination]>;
    /**
     * Gets the delegation between a delegator and validator, if it exists.
     * @param delegator delegator's account address
     * @param validator validator's operator address
     */
    delegation(delegator: AccAddress, validator: ValAddress): Promise<Delegation>;
    /**
     * Queries all unbonding delegations, filtering by delegator, validator, or both.
     *
     * At least one of the parameters must be defined.
     * @param delegator delegator's account address
     * @param validator validator's operator address
     */
    unbondingDelegations(delegator?: AccAddress, validator?: ValAddress, params?: Partial<PaginationOptions & APIParams>): Promise<[UnbondingDelegation[], Pagination]>;
    /**
     * Gets the unbonding delegation between a delegator and validator, if it exists.
     * @param delegator delegator's account address
     * @param validator validator's operator address
     */
    unbondingDelegation(delegator?: AccAddress, validator?: ValAddress): Promise<UnbondingDelegation>;
    /**
     * Queries all redelegations, filterable by delegator, source validator, and target validator.
     * @param delegator delegator's account address
     * @param validatorSrc source validator's operator address (from).
     * @param validatorDst destination validator's operator address (to).
     */
    redelegations(delegator: AccAddress, validatorSrc?: ValAddress, validatorDst?: ValAddress, _params?: Partial<PaginationOptions & APIParams>): Promise<[Redelegation[], Pagination]>;
    /**
     * Gets all bonded validators for a delegator given its address.
     * @param delegator delegator's account address
     */
    bondedValidators(delegator: AccAddress, params?: Partial<PaginationOptions & APIParams>): Promise<[Validator[], Pagination]>;
    /**
     * Get all current registered validators, including validators that are not currently in the validating set.
     */
    validators(params?: Partial<PaginationOptions & APIParams>): Promise<[Validator[], Pagination]>;
    /**
     * Gets the validator information for a specific validator.
     * @param validator validator's operator address
     */
    validator(validator: ValAddress, params?: APIParams): Promise<Validator>;
    /**
     * Gets the current mstaking pool.
     */
    pool(params?: APIParams): Promise<MstakingPool>;
    /**
     * Gets the current Mstaking module's parameters.
     */
    parameters(params?: APIParams): Promise<MstakingParams>;
}
