import Long from "long";
import _m0 from "protobufjs/minimal";
import { Any } from "../../../google/protobuf/any";
import { ExtendedCommitInfo } from "../../../tendermint/abci/types";
import { CurrencyPair } from "../../oracle/v1/genesis";
export declare const protobufPackage = "slinky.alerts.v1";
/**
 * Alert defines the basic meta-data necessary for the alerts module to resolve
 * a claim that the price of a CurrencyPair on-chain is deviating from the price
 * off-chain.
 */
export interface Alert {
    /** height represents the height for which the alert is filed. */
    height: Long;
    /**
     * signer is the signer of this alert, this is the address that will receive
     * the reward in the case of a positive conclusion, or whose bond will get
     * slashed in the event of a negative conclusion.
     */
    signer: string;
    /**
     * currency_pair is the currency-pair that this claim asserts is deviating
     * from the price off-chain.
     */
    currencyPair?: CurrencyPair | undefined;
}
/**
 * AlertStatus contains the module specific state for an alert: Has the alert
 * been concluded? What height was the alert submitted, what height should the
 * alert be purged?
 */
export interface AlertStatus {
    /** ConclusionStatus determines whether the alert has been concluded. */
    conclusionStatus: Long;
    /** SubmissionHeight is the height that the alert was submitted in. */
    submissionHeight: Long;
    /**
     * SubmissionTimestamp is the block-timestamp of the block that the alert was
     * submitted in (as a UTC value in Unix time).
     */
    submissionTimestamp: Long;
    /** PurgeHeight is the height at which the alert should be purged. */
    purgeHeight: Long;
}
/**
 * AlertWithStatus represents a wrapper around the Alert and AlertStatus
 * objects, this is so that the module specific information about Alerts can be
 * packaged together.
 */
export interface AlertWithStatus {
    /** alert is the alert that this status corresponds to. */
    alert?: Alert | undefined;
    /** status is the status of the alert. */
    status?: AlertStatus | undefined;
}
/** Signature is a container for a signer address mapped to a signature. */
export interface Signature {
    signer: string;
    signature: Uint8Array;
}
/**
 * MultiSigConcluson defines a conclusion that is accompanied by a set of
 * signatures. The signature is defined over the alert UID, status, OracleData,
 * and PriceBound. The signatures are used to verify that the conclusion is
 * valid.
 */
export interface MultiSigConclusion {
    /** alert is the alert that this conclusion corresponds to. */
    alert?: Alert | undefined;
    /** oracle_data is the oracle data that this conclusion references. */
    extendedCommitInfo?: ExtendedCommitInfo | undefined;
    /**
     * signatures is a map of signer -> signature. Where the signature is over
     * Alert.UID, PriceBound, the marshalled ExtendedCommitInfo, and status.
     */
    signatures: Signature[];
    /**
     * price-bound is the price bound of the currency-pair off-chain for the
     * designated time-range.
     */
    priceBound?: PriceBound | undefined;
    /** status is the status of the conclusion. */
    status: boolean;
    /**
     * CurrencyPairID is the ID of the currency-pair that this conclusion
     * corresponds to.
     */
    currencyPairID: Long;
}
/**
 * MultiSigConclusionVerificationParams defines the parameters necessary to
 * verify a MultiSigConclusion. It contains a map between signer and public key.
 * Notice, the public-key (value) are the base-64 encoded bytes of the public
 * key. And the signer (key) is the bech32 encoded address of the signer.
 * Notice, all public keys must be secp256 keys.
 */
export interface MultiSigConclusionVerificationParams {
    /** signers is a map of signer -> public key. */
    signers: Any[];
}
/**
 * PriceBound represents the bounds of the price of a currency-pair off chain
 * for a designated time-range
 */
export interface PriceBound {
    high: string;
    low: string;
}
export declare const Alert: {
    encode(message: Alert, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Alert;
    fromJSON(object: any): Alert;
    toJSON(message: Alert): unknown;
    create(base?: DeepPartial<Alert>): Alert;
    fromPartial(object: DeepPartial<Alert>): Alert;
};
export declare const AlertStatus: {
    encode(message: AlertStatus, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AlertStatus;
    fromJSON(object: any): AlertStatus;
    toJSON(message: AlertStatus): unknown;
    create(base?: DeepPartial<AlertStatus>): AlertStatus;
    fromPartial(object: DeepPartial<AlertStatus>): AlertStatus;
};
export declare const AlertWithStatus: {
    encode(message: AlertWithStatus, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AlertWithStatus;
    fromJSON(object: any): AlertWithStatus;
    toJSON(message: AlertWithStatus): unknown;
    create(base?: DeepPartial<AlertWithStatus>): AlertWithStatus;
    fromPartial(object: DeepPartial<AlertWithStatus>): AlertWithStatus;
};
export declare const Signature: {
    encode(message: Signature, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Signature;
    fromJSON(object: any): Signature;
    toJSON(message: Signature): unknown;
    create(base?: DeepPartial<Signature>): Signature;
    fromPartial(object: DeepPartial<Signature>): Signature;
};
export declare const MultiSigConclusion: {
    encode(message: MultiSigConclusion, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MultiSigConclusion;
    fromJSON(object: any): MultiSigConclusion;
    toJSON(message: MultiSigConclusion): unknown;
    create(base?: DeepPartial<MultiSigConclusion>): MultiSigConclusion;
    fromPartial(object: DeepPartial<MultiSigConclusion>): MultiSigConclusion;
};
export declare const MultiSigConclusionVerificationParams: {
    encode(message: MultiSigConclusionVerificationParams, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MultiSigConclusionVerificationParams;
    fromJSON(object: any): MultiSigConclusionVerificationParams;
    toJSON(message: MultiSigConclusionVerificationParams): unknown;
    create(base?: DeepPartial<MultiSigConclusionVerificationParams>): MultiSigConclusionVerificationParams;
    fromPartial(object: DeepPartial<MultiSigConclusionVerificationParams>): MultiSigConclusionVerificationParams;
};
export declare const PriceBound: {
    encode(message: PriceBound, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PriceBound;
    fromJSON(object: any): PriceBound;
    toJSON(message: PriceBound): unknown;
    create(base?: DeepPartial<PriceBound>): PriceBound;
    fromPartial(object: DeepPartial<PriceBound>): PriceBound;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
