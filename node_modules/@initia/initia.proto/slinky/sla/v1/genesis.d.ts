import Long from "long";
import _m0 from "protobufjs/minimal";
import { CurrencyPair } from "../../oracle/v1/genesis";
export declare const protobufPackage = "slinky.sla.v1";
/** GenesisState defines the sla module's genesis state. */
export interface GenesisState {
    /** SLAs are the SLAs that are currently active. */
    slas: PriceFeedSLA[];
    /** PrceFeeds are the price feeds that are currently active. */
    priceFeeds: PriceFeed[];
    /** Params are the parameters for the sla module. */
    params?: Params | undefined;
}
/** Params defines the parameters for the sla module. */
export interface Params {
    /** Enabled is a flag to enable or disable the sla module. */
    enabled: boolean;
}
/**
 * PriceFeedSLA defines the the desired SLA for a given set of price feeds. A
 * price feed is defined to be a set of price prices for the same (currency
 * pair, validator).
 */
export interface PriceFeedSLA {
    /**
     * MaximumViableWindow is the maximum time window that we are interested
     * for the SLA. This is used to determine the moving window of blocks that
     * we are interested in.
     */
    maximumViableWindow: Long;
    /**
     * ExpectedUptime is the expected uptime for the given validator and price
     * feed.
     */
    expectedUptime: string;
    /**
     * SlashConstant is the constant by which we will multiply the deviation from
     * the expected uptime.
     */
    slashConstant: string;
    /**
     * MinimumBlockUpdates is the minimum number of blocks that the
     * validator had to have voted on in the maximum viable window
     * in order to be considered for the SLA.
     */
    minimumBlockUpdates: Long;
    /** Frequency is the frequency at which we will check the SLA. */
    frequency: Long;
    /** ID is the unique identifier for the SLA. */
    id: string;
}
/**
 * PriceFeed defines the object type that will be utilized to monitor how
 * frequently validators are voting with price updates across the network.
 */
export interface PriceFeed {
    /** UpdateMap represents the relevant moving window of price feed updates. */
    updateMap: Uint8Array;
    /**
     * InclusionMap represents the relevant moving window of blocks that the
     * validator has voted on.
     */
    inclusionMap: Uint8Array;
    /** Index corresponds to the current index into the bitmap. */
    index: Long;
    /** Validator represents the validator that this SLA corresponds to. */
    validator: Uint8Array;
    /** CurrencyPair represents the currency pair that this SLA corresponds to. */
    currencyPair?: CurrencyPair | undefined;
    /**
     * MaximumViableWindow represents the maximum number of blocks that can be
     * represented by the bit map.
     */
    maximumViableWindow: Long;
    /** ID corresponds to the SLA ID that this price feed corresponds to. */
    id: string;
}
export declare const GenesisState: {
    encode(message: GenesisState, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GenesisState;
    fromJSON(object: any): GenesisState;
    toJSON(message: GenesisState): unknown;
    create(base?: DeepPartial<GenesisState>): GenesisState;
    fromPartial(object: DeepPartial<GenesisState>): GenesisState;
};
export declare const Params: {
    encode(message: Params, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Params;
    fromJSON(object: any): Params;
    toJSON(message: Params): unknown;
    create(base?: DeepPartial<Params>): Params;
    fromPartial(object: DeepPartial<Params>): Params;
};
export declare const PriceFeedSLA: {
    encode(message: PriceFeedSLA, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PriceFeedSLA;
    fromJSON(object: any): PriceFeedSLA;
    toJSON(message: PriceFeedSLA): unknown;
    create(base?: DeepPartial<PriceFeedSLA>): PriceFeedSLA;
    fromPartial(object: DeepPartial<PriceFeedSLA>): PriceFeedSLA;
};
export declare const PriceFeed: {
    encode(message: PriceFeed, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PriceFeed;
    fromJSON(object: any): PriceFeed;
    toJSON(message: PriceFeed): unknown;
    create(base?: DeepPartial<PriceFeed>): PriceFeed;
    fromPartial(object: DeepPartial<PriceFeed>): PriceFeed;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
