"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PriceFeed = exports.PriceFeedSLA = exports.Params = exports.GenesisState = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const genesis_1 = require("../../oracle/v1/genesis");
exports.protobufPackage = "slinky.sla.v1";
function createBaseGenesisState() {
    return { slas: [], priceFeeds: [], params: undefined };
}
exports.GenesisState = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.slas) {
            exports.PriceFeedSLA.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.priceFeeds) {
            exports.PriceFeed.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.params !== undefined) {
            exports.Params.encode(message.params, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGenesisState();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.slas.push(exports.PriceFeedSLA.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.priceFeeds.push(exports.PriceFeed.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.params = exports.Params.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            slas: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.slas)
                ? object.slas.map((e) => exports.PriceFeedSLA.fromJSON(e))
                : [],
            priceFeeds: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.priceFeeds)
                ? object.priceFeeds.map((e) => exports.PriceFeed.fromJSON(e))
                : [],
            params: isSet(object.params) ? exports.Params.fromJSON(object.params) : undefined,
        };
    },
    toJSON(message) {
        var _a, _b;
        const obj = {};
        if ((_a = message.slas) === null || _a === void 0 ? void 0 : _a.length) {
            obj.slas = message.slas.map((e) => exports.PriceFeedSLA.toJSON(e));
        }
        if ((_b = message.priceFeeds) === null || _b === void 0 ? void 0 : _b.length) {
            obj.priceFeeds = message.priceFeeds.map((e) => exports.PriceFeed.toJSON(e));
        }
        if (message.params !== undefined) {
            obj.params = exports.Params.toJSON(message.params);
        }
        return obj;
    },
    create(base) {
        return exports.GenesisState.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseGenesisState();
        message.slas = ((_a = object.slas) === null || _a === void 0 ? void 0 : _a.map((e) => exports.PriceFeedSLA.fromPartial(e))) || [];
        message.priceFeeds = ((_b = object.priceFeeds) === null || _b === void 0 ? void 0 : _b.map((e) => exports.PriceFeed.fromPartial(e))) || [];
        message.params =
            object.params !== undefined && object.params !== null ? exports.Params.fromPartial(object.params) : undefined;
        return message;
    },
};
function createBaseParams() {
    return { enabled: false };
}
exports.Params = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.enabled === true) {
            writer.uint32(8).bool(message.enabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.enabled = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false };
    },
    toJSON(message) {
        const obj = {};
        if (message.enabled === true) {
            obj.enabled = message.enabled;
        }
        return obj;
    },
    create(base) {
        return exports.Params.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseParams();
        message.enabled = (_a = object.enabled) !== null && _a !== void 0 ? _a : false;
        return message;
    },
};
function createBasePriceFeedSLA() {
    return {
        maximumViableWindow: long_1.default.UZERO,
        expectedUptime: "",
        slashConstant: "",
        minimumBlockUpdates: long_1.default.UZERO,
        frequency: long_1.default.UZERO,
        id: "",
    };
}
exports.PriceFeedSLA = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.maximumViableWindow.isZero()) {
            writer.uint32(8).uint64(message.maximumViableWindow);
        }
        if (message.expectedUptime !== "") {
            writer.uint32(18).string(message.expectedUptime);
        }
        if (message.slashConstant !== "") {
            writer.uint32(26).string(message.slashConstant);
        }
        if (!message.minimumBlockUpdates.isZero()) {
            writer.uint32(32).uint64(message.minimumBlockUpdates);
        }
        if (!message.frequency.isZero()) {
            writer.uint32(40).uint64(message.frequency);
        }
        if (message.id !== "") {
            writer.uint32(50).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePriceFeedSLA();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.maximumViableWindow = reader.uint64();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.expectedUptime = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.slashConstant = reader.string();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.minimumBlockUpdates = reader.uint64();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.frequency = reader.uint64();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            maximumViableWindow: isSet(object.maximumViableWindow)
                ? long_1.default.fromValue(object.maximumViableWindow)
                : long_1.default.UZERO,
            expectedUptime: isSet(object.expectedUptime) ? globalThis.String(object.expectedUptime) : "",
            slashConstant: isSet(object.slashConstant) ? globalThis.String(object.slashConstant) : "",
            minimumBlockUpdates: isSet(object.minimumBlockUpdates)
                ? long_1.default.fromValue(object.minimumBlockUpdates)
                : long_1.default.UZERO,
            frequency: isSet(object.frequency) ? long_1.default.fromValue(object.frequency) : long_1.default.UZERO,
            id: isSet(object.id) ? globalThis.String(object.id) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (!message.maximumViableWindow.isZero()) {
            obj.maximumViableWindow = (message.maximumViableWindow || long_1.default.UZERO).toString();
        }
        if (message.expectedUptime !== "") {
            obj.expectedUptime = message.expectedUptime;
        }
        if (message.slashConstant !== "") {
            obj.slashConstant = message.slashConstant;
        }
        if (!message.minimumBlockUpdates.isZero()) {
            obj.minimumBlockUpdates = (message.minimumBlockUpdates || long_1.default.UZERO).toString();
        }
        if (!message.frequency.isZero()) {
            obj.frequency = (message.frequency || long_1.default.UZERO).toString();
        }
        if (message.id !== "") {
            obj.id = message.id;
        }
        return obj;
    },
    create(base) {
        return exports.PriceFeedSLA.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBasePriceFeedSLA();
        message.maximumViableWindow =
            object.maximumViableWindow !== undefined && object.maximumViableWindow !== null
                ? long_1.default.fromValue(object.maximumViableWindow)
                : long_1.default.UZERO;
        message.expectedUptime = (_a = object.expectedUptime) !== null && _a !== void 0 ? _a : "";
        message.slashConstant = (_b = object.slashConstant) !== null && _b !== void 0 ? _b : "";
        message.minimumBlockUpdates =
            object.minimumBlockUpdates !== undefined && object.minimumBlockUpdates !== null
                ? long_1.default.fromValue(object.minimumBlockUpdates)
                : long_1.default.UZERO;
        message.frequency =
            object.frequency !== undefined && object.frequency !== null
                ? long_1.default.fromValue(object.frequency)
                : long_1.default.UZERO;
        message.id = (_c = object.id) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBasePriceFeed() {
    return {
        updateMap: new Uint8Array(0),
        inclusionMap: new Uint8Array(0),
        index: long_1.default.UZERO,
        validator: new Uint8Array(0),
        currencyPair: undefined,
        maximumViableWindow: long_1.default.UZERO,
        id: "",
    };
}
exports.PriceFeed = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.updateMap.length !== 0) {
            writer.uint32(10).bytes(message.updateMap);
        }
        if (message.inclusionMap.length !== 0) {
            writer.uint32(18).bytes(message.inclusionMap);
        }
        if (!message.index.isZero()) {
            writer.uint32(24).uint64(message.index);
        }
        if (message.validator.length !== 0) {
            writer.uint32(34).bytes(message.validator);
        }
        if (message.currencyPair !== undefined) {
            genesis_1.CurrencyPair.encode(message.currencyPair, writer.uint32(42).fork()).ldelim();
        }
        if (!message.maximumViableWindow.isZero()) {
            writer.uint32(48).uint64(message.maximumViableWindow);
        }
        if (message.id !== "") {
            writer.uint32(58).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePriceFeed();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.updateMap = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.inclusionMap = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.index = reader.uint64();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.validator = reader.bytes();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.currencyPair = genesis_1.CurrencyPair.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.maximumViableWindow = reader.uint64();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            updateMap: isSet(object.updateMap) ? bytesFromBase64(object.updateMap) : new Uint8Array(0),
            inclusionMap: isSet(object.inclusionMap) ? bytesFromBase64(object.inclusionMap) : new Uint8Array(0),
            index: isSet(object.index) ? long_1.default.fromValue(object.index) : long_1.default.UZERO,
            validator: isSet(object.validator) ? bytesFromBase64(object.validator) : new Uint8Array(0),
            currencyPair: isSet(object.currencyPair) ? genesis_1.CurrencyPair.fromJSON(object.currencyPair) : undefined,
            maximumViableWindow: isSet(object.maximumViableWindow)
                ? long_1.default.fromValue(object.maximumViableWindow)
                : long_1.default.UZERO,
            id: isSet(object.id) ? globalThis.String(object.id) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.updateMap.length !== 0) {
            obj.updateMap = base64FromBytes(message.updateMap);
        }
        if (message.inclusionMap.length !== 0) {
            obj.inclusionMap = base64FromBytes(message.inclusionMap);
        }
        if (!message.index.isZero()) {
            obj.index = (message.index || long_1.default.UZERO).toString();
        }
        if (message.validator.length !== 0) {
            obj.validator = base64FromBytes(message.validator);
        }
        if (message.currencyPair !== undefined) {
            obj.currencyPair = genesis_1.CurrencyPair.toJSON(message.currencyPair);
        }
        if (!message.maximumViableWindow.isZero()) {
            obj.maximumViableWindow = (message.maximumViableWindow || long_1.default.UZERO).toString();
        }
        if (message.id !== "") {
            obj.id = message.id;
        }
        return obj;
    },
    create(base) {
        return exports.PriceFeed.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBasePriceFeed();
        message.updateMap = (_a = object.updateMap) !== null && _a !== void 0 ? _a : new Uint8Array(0);
        message.inclusionMap = (_b = object.inclusionMap) !== null && _b !== void 0 ? _b : new Uint8Array(0);
        message.index =
            object.index !== undefined && object.index !== null ? long_1.default.fromValue(object.index) : long_1.default.UZERO;
        message.validator = (_c = object.validator) !== null && _c !== void 0 ? _c : new Uint8Array(0);
        message.currencyPair =
            object.currencyPair !== undefined && object.currencyPair !== null
                ? genesis_1.CurrencyPair.fromPartial(object.currencyPair)
                : undefined;
        message.maximumViableWindow =
            object.maximumViableWindow !== undefined && object.maximumViableWindow !== null
                ? long_1.default.fromValue(object.maximumViableWindow)
                : long_1.default.UZERO;
        message.id = (_d = object.id) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=genesis.js.map