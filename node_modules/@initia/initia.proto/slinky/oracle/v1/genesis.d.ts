import Long from "long";
import _m0 from "protobufjs/minimal";
export declare const protobufPackage = "slinky.oracle.v1";
/**
 * CurrencyPair is the standard representation of a pair of assets, where one
 * (Base) is priced in terms of the other (Quote)
 */
export interface CurrencyPair {
    Base: string;
    Quote: string;
}
/**
 * QuotePrice is the representation of the aggregated prices for a CurrencyPair,
 * where price represents the price of Base in terms of Quote
 */
export interface QuotePrice {
    price: string;
    /**
     * BlockTimestamp tracks the block height associated with this price update.
     * We include block timestamp alongside the price to ensure that smart
     * contracts and applications are not utilizing stale oracle prices
     */
    blockTimestamp?: Date | undefined;
    /** BlockHeight is height of block mentioned above */
    blockHeight: Long;
}
/**
 * CurrencyPairState represents the stateful information tracked by the x/oracle
 * module per-currency-pair.
 */
export interface CurrencyPairState {
    /**
     * QuotePrice is the latest price for a currency-pair, notice this value can
     * be null in the case that no price exists for the currency-pair
     */
    price?: QuotePrice | undefined;
    /** Nonce is the number of updates this currency-pair has received */
    nonce: Long;
    /** ID is the ID of the CurrencyPair */
    id: Long;
}
/**
 * CurrencyPairGenesis is the information necessary for initialization of a
 * CurrencyPair.
 */
export interface CurrencyPairGenesis {
    /** The CurrencyPair to be added to module state */
    currencyPair?: CurrencyPair | undefined;
    /**
     * A genesis price if one exists (note this will be empty, unless it results
     * from forking the state of this module)
     */
    currencyPairPrice?: QuotePrice | undefined;
    /**
     * nonce is the nonce (number of updates) for the CP (same case as above,
     * likely 0 unless it results from fork of module)
     */
    nonce: Long;
    /** id is the ID of the CurrencyPair */
    id: Long;
}
/**
 * GenesisState is the genesis-state for the x/oracle module, it takes a set of
 * predefined CurrencyPairGeneses
 */
export interface GenesisState {
    /**
     * CurrencyPairGenesis is the set of CurrencyPairGeneses for the module. I.e
     * the starting set of CurrencyPairs for the module + information regarding
     * their latest update.
     */
    currencyPairGenesis: CurrencyPairGenesis[];
    /** NextID is the next ID to be used for a CurrencyPair */
    nextId: Long;
}
export declare const CurrencyPair: {
    encode(message: CurrencyPair, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CurrencyPair;
    fromJSON(object: any): CurrencyPair;
    toJSON(message: CurrencyPair): unknown;
    create(base?: DeepPartial<CurrencyPair>): CurrencyPair;
    fromPartial(object: DeepPartial<CurrencyPair>): CurrencyPair;
};
export declare const QuotePrice: {
    encode(message: QuotePrice, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QuotePrice;
    fromJSON(object: any): QuotePrice;
    toJSON(message: QuotePrice): unknown;
    create(base?: DeepPartial<QuotePrice>): QuotePrice;
    fromPartial(object: DeepPartial<QuotePrice>): QuotePrice;
};
export declare const CurrencyPairState: {
    encode(message: CurrencyPairState, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CurrencyPairState;
    fromJSON(object: any): CurrencyPairState;
    toJSON(message: CurrencyPairState): unknown;
    create(base?: DeepPartial<CurrencyPairState>): CurrencyPairState;
    fromPartial(object: DeepPartial<CurrencyPairState>): CurrencyPairState;
};
export declare const CurrencyPairGenesis: {
    encode(message: CurrencyPairGenesis, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): CurrencyPairGenesis;
    fromJSON(object: any): CurrencyPairGenesis;
    toJSON(message: CurrencyPairGenesis): unknown;
    create(base?: DeepPartial<CurrencyPairGenesis>): CurrencyPairGenesis;
    fromPartial(object: DeepPartial<CurrencyPairGenesis>): CurrencyPairGenesis;
};
export declare const GenesisState: {
    encode(message: GenesisState, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GenesisState;
    fromJSON(object: any): GenesisState;
    toJSON(message: GenesisState): unknown;
    create(base?: DeepPartial<GenesisState>): GenesisState;
    fromPartial(object: DeepPartial<GenesisState>): GenesisState;
};
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
