"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BridgeInfo = exports.ValidatorUpdates = exports.Validator = exports.Params = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const coin_1 = require("../../../cosmos/base/v1beta1/coin");
const any_1 = require("../../../google/protobuf/any");
const types_1 = require("../../../tendermint/abci/types");
const types_2 = require("../../ophost/v1/types");
exports.protobufPackage = "opinit.opchild.v1";
function createBaseParams() {
    return {
        maxValidators: 0,
        historicalEntries: 0,
        minGasPrices: [],
        bridgeExecutor: "",
        admin: "",
        feeWhitelist: [],
    };
}
exports.Params = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.maxValidators !== 0) {
            writer.uint32(8).uint32(message.maxValidators);
        }
        if (message.historicalEntries !== 0) {
            writer.uint32(16).uint32(message.historicalEntries);
        }
        for (const v of message.minGasPrices) {
            coin_1.DecCoin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.bridgeExecutor !== "") {
            writer.uint32(34).string(message.bridgeExecutor);
        }
        if (message.admin !== "") {
            writer.uint32(42).string(message.admin);
        }
        for (const v of message.feeWhitelist) {
            writer.uint32(50).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.maxValidators = reader.uint32();
                    break;
                case 2:
                    message.historicalEntries = reader.uint32();
                    break;
                case 3:
                    message.minGasPrices.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.bridgeExecutor = reader.string();
                    break;
                case 5:
                    message.admin = reader.string();
                    break;
                case 6:
                    message.feeWhitelist.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            maxValidators: isSet(object.maxValidators) ? Number(object.maxValidators) : 0,
            historicalEntries: isSet(object.historicalEntries) ? Number(object.historicalEntries) : 0,
            minGasPrices: Array.isArray(object === null || object === void 0 ? void 0 : object.minGasPrices)
                ? object.minGasPrices.map((e) => coin_1.DecCoin.fromJSON(e))
                : [],
            bridgeExecutor: isSet(object.bridgeExecutor) ? String(object.bridgeExecutor) : "",
            admin: isSet(object.admin) ? String(object.admin) : "",
            feeWhitelist: Array.isArray(object === null || object === void 0 ? void 0 : object.feeWhitelist) ? object.feeWhitelist.map((e) => String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        message.maxValidators !== undefined && (obj.maxValidators = Math.round(message.maxValidators));
        message.historicalEntries !== undefined &&
            (obj.historicalEntries = Math.round(message.historicalEntries));
        if (message.minGasPrices) {
            obj.minGasPrices = message.minGasPrices.map((e) => (e ? coin_1.DecCoin.toJSON(e) : undefined));
        }
        else {
            obj.minGasPrices = [];
        }
        message.bridgeExecutor !== undefined && (obj.bridgeExecutor = message.bridgeExecutor);
        message.admin !== undefined && (obj.admin = message.admin);
        if (message.feeWhitelist) {
            obj.feeWhitelist = message.feeWhitelist.map((e) => e);
        }
        else {
            obj.feeWhitelist = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f;
        const message = createBaseParams();
        message.maxValidators = (_a = object.maxValidators) !== null && _a !== void 0 ? _a : 0;
        message.historicalEntries = (_b = object.historicalEntries) !== null && _b !== void 0 ? _b : 0;
        message.minGasPrices = ((_c = object.minGasPrices) === null || _c === void 0 ? void 0 : _c.map((e) => coin_1.DecCoin.fromPartial(e))) || [];
        message.bridgeExecutor = (_d = object.bridgeExecutor) !== null && _d !== void 0 ? _d : "";
        message.admin = (_e = object.admin) !== null && _e !== void 0 ? _e : "";
        message.feeWhitelist = ((_f = object.feeWhitelist) === null || _f === void 0 ? void 0 : _f.map((e) => e)) || [];
        return message;
    },
};
function createBaseValidator() {
    return { moniker: "", operatorAddress: "", consensusPubkey: undefined, consPower: long_1.default.ZERO };
}
exports.Validator = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.moniker !== "") {
            writer.uint32(10).string(message.moniker);
        }
        if (message.operatorAddress !== "") {
            writer.uint32(18).string(message.operatorAddress);
        }
        if (message.consensusPubkey !== undefined) {
            any_1.Any.encode(message.consensusPubkey, writer.uint32(26).fork()).ldelim();
        }
        if (!message.consPower.isZero()) {
            writer.uint32(32).int64(message.consPower);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.moniker = reader.string();
                    break;
                case 2:
                    message.operatorAddress = reader.string();
                    break;
                case 3:
                    message.consensusPubkey = any_1.Any.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.consPower = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            moniker: isSet(object.moniker) ? String(object.moniker) : "",
            operatorAddress: isSet(object.operatorAddress) ? String(object.operatorAddress) : "",
            consensusPubkey: isSet(object.consensusPubkey) ? any_1.Any.fromJSON(object.consensusPubkey) : undefined,
            consPower: isSet(object.consPower) ? long_1.default.fromValue(object.consPower) : long_1.default.ZERO,
        };
    },
    toJSON(message) {
        const obj = {};
        message.moniker !== undefined && (obj.moniker = message.moniker);
        message.operatorAddress !== undefined && (obj.operatorAddress = message.operatorAddress);
        message.consensusPubkey !== undefined &&
            (obj.consensusPubkey = message.consensusPubkey ? any_1.Any.toJSON(message.consensusPubkey) : undefined);
        message.consPower !== undefined && (obj.consPower = (message.consPower || long_1.default.ZERO).toString());
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseValidator();
        message.moniker = (_a = object.moniker) !== null && _a !== void 0 ? _a : "";
        message.operatorAddress = (_b = object.operatorAddress) !== null && _b !== void 0 ? _b : "";
        message.consensusPubkey =
            object.consensusPubkey !== undefined && object.consensusPubkey !== null
                ? any_1.Any.fromPartial(object.consensusPubkey)
                : undefined;
        message.consPower =
            object.consPower !== undefined && object.consPower !== null
                ? long_1.default.fromValue(object.consPower)
                : long_1.default.ZERO;
        return message;
    },
};
function createBaseValidatorUpdates() {
    return { updates: [] };
}
exports.ValidatorUpdates = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.updates) {
            types_1.ValidatorUpdate.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorUpdates();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.updates.push(types_1.ValidatorUpdate.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            updates: Array.isArray(object === null || object === void 0 ? void 0 : object.updates)
                ? object.updates.map((e) => types_1.ValidatorUpdate.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.updates) {
            obj.updates = message.updates.map((e) => (e ? types_1.ValidatorUpdate.toJSON(e) : undefined));
        }
        else {
            obj.updates = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseValidatorUpdates();
        message.updates = ((_a = object.updates) === null || _a === void 0 ? void 0 : _a.map((e) => types_1.ValidatorUpdate.fromPartial(e))) || [];
        return message;
    },
};
function createBaseBridgeInfo() {
    return { bridgeId: long_1.default.UZERO, bridgeAddr: "", l1ChainId: "", l1ClientId: "", bridgeConfig: undefined };
}
exports.BridgeInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.bridgeId.isZero()) {
            writer.uint32(8).uint64(message.bridgeId);
        }
        if (message.bridgeAddr !== "") {
            writer.uint32(18).string(message.bridgeAddr);
        }
        if (message.l1ChainId !== "") {
            writer.uint32(26).string(message.l1ChainId);
        }
        if (message.l1ClientId !== "") {
            writer.uint32(34).string(message.l1ClientId);
        }
        if (message.bridgeConfig !== undefined) {
            types_2.BridgeConfig.encode(message.bridgeConfig, writer.uint32(42).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBridgeInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.bridgeId = reader.uint64();
                    break;
                case 2:
                    message.bridgeAddr = reader.string();
                    break;
                case 3:
                    message.l1ChainId = reader.string();
                    break;
                case 4:
                    message.l1ClientId = reader.string();
                    break;
                case 5:
                    message.bridgeConfig = types_2.BridgeConfig.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            bridgeId: isSet(object.bridgeId) ? long_1.default.fromValue(object.bridgeId) : long_1.default.UZERO,
            bridgeAddr: isSet(object.bridgeAddr) ? String(object.bridgeAddr) : "",
            l1ChainId: isSet(object.l1ChainId) ? String(object.l1ChainId) : "",
            l1ClientId: isSet(object.l1ClientId) ? String(object.l1ClientId) : "",
            bridgeConfig: isSet(object.bridgeConfig) ? types_2.BridgeConfig.fromJSON(object.bridgeConfig) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.bridgeId !== undefined && (obj.bridgeId = (message.bridgeId || long_1.default.UZERO).toString());
        message.bridgeAddr !== undefined && (obj.bridgeAddr = message.bridgeAddr);
        message.l1ChainId !== undefined && (obj.l1ChainId = message.l1ChainId);
        message.l1ClientId !== undefined && (obj.l1ClientId = message.l1ClientId);
        message.bridgeConfig !== undefined &&
            (obj.bridgeConfig = message.bridgeConfig ? types_2.BridgeConfig.toJSON(message.bridgeConfig) : undefined);
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseBridgeInfo();
        message.bridgeId =
            object.bridgeId !== undefined && object.bridgeId !== null
                ? long_1.default.fromValue(object.bridgeId)
                : long_1.default.UZERO;
        message.bridgeAddr = (_a = object.bridgeAddr) !== null && _a !== void 0 ? _a : "";
        message.l1ChainId = (_b = object.l1ChainId) !== null && _b !== void 0 ? _b : "";
        message.l1ClientId = (_c = object.l1ClientId) !== null && _c !== void 0 ? _c : "";
        message.bridgeConfig =
            object.bridgeConfig !== undefined && object.bridgeConfig !== null
                ? types_2.BridgeConfig.fromPartial(object.bridgeConfig)
                : undefined;
        return message;
    },
};
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=types.js.map