"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Output = exports.TokenPair = exports.BatchInfo = exports.BridgeConfig = exports.Params = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const coin_1 = require("../../../cosmos/base/v1beta1/coin");
const duration_1 = require("../../../google/protobuf/duration");
const timestamp_1 = require("../../../google/protobuf/timestamp");
exports.protobufPackage = "opinit.ophost.v1";
function createBaseParams() {
    return { registrationFee: [] };
}
exports.Params = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.registrationFee) {
            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.registrationFee.push(coin_1.Coin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            registrationFee: Array.isArray(object === null || object === void 0 ? void 0 : object.registrationFee)
                ? object.registrationFee.map((e) => coin_1.Coin.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.registrationFee) {
            obj.registrationFee = message.registrationFee.map((e) => (e ? coin_1.Coin.toJSON(e) : undefined));
        }
        else {
            obj.registrationFee = [];
        }
        return obj;
    },
    fromPartial(object) {
        var _a;
        const message = createBaseParams();
        message.registrationFee = ((_a = object.registrationFee) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];
        return message;
    },
};
function createBaseBridgeConfig() {
    return {
        challenger: "",
        proposer: "",
        batchInfo: undefined,
        submissionInterval: undefined,
        finalizationPeriod: undefined,
        submissionStartTime: undefined,
        metadata: new Uint8Array(),
    };
}
exports.BridgeConfig = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.challenger !== "") {
            writer.uint32(10).string(message.challenger);
        }
        if (message.proposer !== "") {
            writer.uint32(18).string(message.proposer);
        }
        if (message.batchInfo !== undefined) {
            exports.BatchInfo.encode(message.batchInfo, writer.uint32(26).fork()).ldelim();
        }
        if (message.submissionInterval !== undefined) {
            duration_1.Duration.encode(message.submissionInterval, writer.uint32(34).fork()).ldelim();
        }
        if (message.finalizationPeriod !== undefined) {
            duration_1.Duration.encode(message.finalizationPeriod, writer.uint32(42).fork()).ldelim();
        }
        if (message.submissionStartTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.submissionStartTime), writer.uint32(50).fork()).ldelim();
        }
        if (message.metadata.length !== 0) {
            writer.uint32(58).bytes(message.metadata);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBridgeConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.challenger = reader.string();
                    break;
                case 2:
                    message.proposer = reader.string();
                    break;
                case 3:
                    message.batchInfo = exports.BatchInfo.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.submissionInterval = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.finalizationPeriod = duration_1.Duration.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.submissionStartTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.metadata = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            challenger: isSet(object.challenger) ? String(object.challenger) : "",
            proposer: isSet(object.proposer) ? String(object.proposer) : "",
            batchInfo: isSet(object.batchInfo) ? exports.BatchInfo.fromJSON(object.batchInfo) : undefined,
            submissionInterval: isSet(object.submissionInterval)
                ? duration_1.Duration.fromJSON(object.submissionInterval)
                : undefined,
            finalizationPeriod: isSet(object.finalizationPeriod)
                ? duration_1.Duration.fromJSON(object.finalizationPeriod)
                : undefined,
            submissionStartTime: isSet(object.submissionStartTime)
                ? fromJsonTimestamp(object.submissionStartTime)
                : undefined,
            metadata: isSet(object.metadata) ? bytesFromBase64(object.metadata) : new Uint8Array(),
        };
    },
    toJSON(message) {
        const obj = {};
        message.challenger !== undefined && (obj.challenger = message.challenger);
        message.proposer !== undefined && (obj.proposer = message.proposer);
        message.batchInfo !== undefined &&
            (obj.batchInfo = message.batchInfo ? exports.BatchInfo.toJSON(message.batchInfo) : undefined);
        message.submissionInterval !== undefined &&
            (obj.submissionInterval = message.submissionInterval
                ? duration_1.Duration.toJSON(message.submissionInterval)
                : undefined);
        message.finalizationPeriod !== undefined &&
            (obj.finalizationPeriod = message.finalizationPeriod
                ? duration_1.Duration.toJSON(message.finalizationPeriod)
                : undefined);
        message.submissionStartTime !== undefined &&
            (obj.submissionStartTime = message.submissionStartTime.toISOString());
        message.metadata !== undefined &&
            (obj.metadata = base64FromBytes(message.metadata !== undefined ? message.metadata : new Uint8Array()));
        return obj;
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseBridgeConfig();
        message.challenger = (_a = object.challenger) !== null && _a !== void 0 ? _a : "";
        message.proposer = (_b = object.proposer) !== null && _b !== void 0 ? _b : "";
        message.batchInfo =
            object.batchInfo !== undefined && object.batchInfo !== null
                ? exports.BatchInfo.fromPartial(object.batchInfo)
                : undefined;
        message.submissionInterval =
            object.submissionInterval !== undefined && object.submissionInterval !== null
                ? duration_1.Duration.fromPartial(object.submissionInterval)
                : undefined;
        message.finalizationPeriod =
            object.finalizationPeriod !== undefined && object.finalizationPeriod !== null
                ? duration_1.Duration.fromPartial(object.finalizationPeriod)
                : undefined;
        message.submissionStartTime = (_c = object.submissionStartTime) !== null && _c !== void 0 ? _c : undefined;
        message.metadata = (_d = object.metadata) !== null && _d !== void 0 ? _d : new Uint8Array();
        return message;
    },
};
function createBaseBatchInfo() {
    return { submitter: "", chain: "" };
}
exports.BatchInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.submitter !== "") {
            writer.uint32(10).string(message.submitter);
        }
        if (message.chain !== "") {
            writer.uint32(18).string(message.chain);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBatchInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.submitter = reader.string();
                    break;
                case 2:
                    message.chain = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            submitter: isSet(object.submitter) ? String(object.submitter) : "",
            chain: isSet(object.chain) ? String(object.chain) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.submitter !== undefined && (obj.submitter = message.submitter);
        message.chain !== undefined && (obj.chain = message.chain);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseBatchInfo();
        message.submitter = (_a = object.submitter) !== null && _a !== void 0 ? _a : "";
        message.chain = (_b = object.chain) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseTokenPair() {
    return { l1Denom: "", l2Denom: "" };
}
exports.TokenPair = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.l1Denom !== "") {
            writer.uint32(10).string(message.l1Denom);
        }
        if (message.l2Denom !== "") {
            writer.uint32(18).string(message.l2Denom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTokenPair();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.l1Denom = reader.string();
                    break;
                case 2:
                    message.l2Denom = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            l1Denom: isSet(object.l1Denom) ? String(object.l1Denom) : "",
            l2Denom: isSet(object.l2Denom) ? String(object.l2Denom) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        message.l1Denom !== undefined && (obj.l1Denom = message.l1Denom);
        message.l2Denom !== undefined && (obj.l2Denom = message.l2Denom);
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseTokenPair();
        message.l1Denom = (_a = object.l1Denom) !== null && _a !== void 0 ? _a : "";
        message.l2Denom = (_b = object.l2Denom) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseOutput() {
    return { outputRoot: new Uint8Array(), l1BlockTime: undefined, l2BlockNumber: long_1.default.UZERO };
}
exports.Output = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.outputRoot.length !== 0) {
            writer.uint32(10).bytes(message.outputRoot);
        }
        if (message.l1BlockTime !== undefined) {
            timestamp_1.Timestamp.encode(toTimestamp(message.l1BlockTime), writer.uint32(18).fork()).ldelim();
        }
        if (!message.l2BlockNumber.isZero()) {
            writer.uint32(24).uint64(message.l2BlockNumber);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOutput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.outputRoot = reader.bytes();
                    break;
                case 2:
                    message.l1BlockTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.l2BlockNumber = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            outputRoot: isSet(object.outputRoot) ? bytesFromBase64(object.outputRoot) : new Uint8Array(),
            l1BlockTime: isSet(object.l1BlockTime) ? fromJsonTimestamp(object.l1BlockTime) : undefined,
            l2BlockNumber: isSet(object.l2BlockNumber) ? long_1.default.fromValue(object.l2BlockNumber) : long_1.default.UZERO,
        };
    },
    toJSON(message) {
        const obj = {};
        message.outputRoot !== undefined &&
            (obj.outputRoot = base64FromBytes(message.outputRoot !== undefined ? message.outputRoot : new Uint8Array()));
        message.l1BlockTime !== undefined && (obj.l1BlockTime = message.l1BlockTime.toISOString());
        message.l2BlockNumber !== undefined &&
            (obj.l2BlockNumber = (message.l2BlockNumber || long_1.default.UZERO).toString());
        return obj;
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseOutput();
        message.outputRoot = (_a = object.outputRoot) !== null && _a !== void 0 ? _a : new Uint8Array();
        message.l1BlockTime = (_b = object.l1BlockTime) !== null && _b !== void 0 ? _b : undefined;
        message.l2BlockNumber =
            object.l2BlockNumber !== undefined && object.l2BlockNumber !== null
                ? long_1.default.fromValue(object.l2BlockNumber)
                : long_1.default.UZERO;
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function toTimestamp(date) {
    const seconds = numberToLong(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = t.seconds.toNumber() * 1000;
    millis += t.nanos / 1000000;
    return new Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new Date(o);
    }
    else {
        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));
    }
}
function numberToLong(number) {
    return long_1.default.fromNumber(number);
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=types.js.map